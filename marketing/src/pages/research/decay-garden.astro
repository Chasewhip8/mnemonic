---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('decay-garden')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="demo-garden-wrapper bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10">
        <div class="flex items-center gap-3">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/60">Decay Garden</span>
          <span class="font-mono text-[10px] text-chrome-dark/40">15 memories</span>
        </div>
        <div class="flex items-center gap-2">
          <span class="font-mono text-[10px] text-chrome-dark/40">Season:</span>
          <span id="season-label" class="font-mono text-[10px] font-bold text-brass">Spring</span>
          <button id="winter-btn" class="ml-2 font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-chrome-dark/60 hover:text-brass hover:border-brass/40 transition-colors">
            Winter cleanup
          </button>
        </div>
      </div>

      <!-- Garden -->
      <div id="garden-bed" class="relative px-6 py-8 min-h-[340px]">
        <div class="garden-grid grid grid-cols-5 gap-x-4 gap-y-2 items-end justify-items-center">
          <!-- Plants rendered by JS -->
        </div>
      </div>

      <!-- Detail panel -->
      <div id="plant-detail" class="hidden px-5 py-3 border-t border-brass/10 bg-steel/30">
        <div class="flex items-start justify-between gap-4">
          <div>
            <div id="detail-trigger" class="font-serif text-sm text-chrome mb-1"></div>
            <div id="detail-learning" class="font-serif text-[12px] text-chrome-dark/60 mb-2 max-w-lg"></div>
            <div class="flex items-center gap-4">
              <span id="detail-confidence" class="font-mono text-[10px]"></span>
              <span id="detail-recalled" class="font-mono text-[10px] text-chrome-dark/40"></span>
              <span id="detail-scope" class="font-mono text-[10px] text-chrome-dark/40"></span>
            </div>
          </div>
          <div class="flex items-center gap-2 shrink-0">
            <button id="water-btn" class="font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-brass/70 hover:text-brass hover:border-brass/40 transition-colors">
              Water (+0.1)
            </button>
            <button id="transplant-btn" class="font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-chrome-dark/50 hover:text-chrome hover:border-brass/40 transition-colors">
              Transplant
            </button>
            <button id="prune-btn" class="font-mono text-[10px] px-2.5 py-1 rounded-sm border border-red-500/20 text-red-400/60 hover:text-red-400 hover:border-red-500/40 transition-colors">
              Prune
            </button>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <div class="px-5 py-2.5 border-t border-brass/10 flex items-center justify-between">
        <span class="font-mono text-[10px] text-chrome-dark/30">Hover a plant to inspect. Winter cleanup removes memories below 0.3.</span>
        <span id="garden-stats" class="font-mono text-[10px] text-chrome-dark/30"></span>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#philosophical-note" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Philosophical note</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>
  <p>
    Imagine walking through a garden. Not a garden of flowers, exactly, but a garden of things you know. Each plant represents a memory your agent has stored: a deployment practice, a debugging shortcut, a preference about code style. Some are tall and luminous, swaying gently, radiating the warm light of high confidence. Others are stunted, grayed out, leaning toward the soil as if they have forgotten why they grew in the first place.
  </p>
  <p>
    This is the core experience of the decay garden: a spatial, organic visualization of memory health. You do not read a table. You do not scan a list. You walk through, and you see at a glance what is thriving and what is dying. The tall golden plant in the center is the thing your agent knows best. The barely visible stub near the edge is something it learned once, months ago, and has never needed since.
  </p>
  <p>
    The interaction model borrows from actual gardening. You water a plant to boost its confidence. You prune one to remove it entirely. You transplant one to move it from a session scope to a shared scope, broadening its reach. There is a seasonal rhythm too: winter cleanup is a batch operation that removes everything below a confidence threshold. It is not deletion -- it is composting.
  </p>
  <p>
    What makes this distinct from a dashboard is the quality of attention it invites. Dashboards ask you to analyze. Gardens ask you to notice. You see the wilting before you see the number. You feel concern for a memory before you decide what to do about it. This is not an accident. It is the point.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>
  <p>
    The decay garden reveals something that tables and lists obscure: the health distribution of memory. Most memory systems show you what is stored. This one shows you what is alive. The distinction matters because storage and vitality are not the same thing. A memory can exist in the database and be functionally dead -- low confidence, never recalled, semantically orphaned from everything the agent currently cares about.
  </p>
  <p>
    When you visualize memories as living things, patterns emerge that are invisible in a flat list. You notice clustering: memories about deployment are all healthy, but memories about testing are uniformly wilted. You notice outliers: one memory has extraordinarily high confidence despite being months old, suggesting it is load-bearing. You notice decay gradients: a whole region of the garden dimming over time, indicating that a topic area is drifting out of relevance.
  </p>
  <p>
    The garden also reveals the ratio between what is well-understood and what is shaky. This is not something you can easily compute from a table. But in a garden, you feel it. Two-thirds lush and one-third wilting tells a different story than one-third lush and two-thirds wilting, and both tell a different story than everything hovering at medium confidence. The distribution shape is the insight.
  </p>
  <p>
    There is a deeper revelation here too: some memories are load-bearing and others are dead weight. A filing cabinet treats every entry equally. A garden does not. The tall, bright plant in the center is doing real work. The stub at the edge is occupying space. The garden makes this hierarchy visible without requiring you to compute it.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>
  <p>
    Deja already has the raw ingredients for a decay garden. Every learning has a <code>confidence</code> field that ranges from 0.0 to 1.0. Confidence grows when a memory is reinforced through recall and shrinks through natural decay. The <code>PATCH /learnings/:id</code> endpoint can update confidence, and the daily cleanup cron already removes learnings that fall below a threshold.
  </p>
  <p>
    What the garden adds is a <code>last_recalled_at</code> timestamp -- which deja does not yet track but trivially could. This timestamp would let the visualization distinguish between a memory that is low-confidence because it was always uncertain and one that is low-confidence because it has been forgotten. The first might be a guess that was never validated. The second might be solid knowledge that simply has not been needed in a while. These are different situations requiring different responses: one needs verification, the other needs a gentle boost.
  </p>
  <p>
    The "water" action maps directly to a PATCH request incrementing confidence. "Prune" maps to DELETE. "Transplant" maps to a PATCH changing the <code>scope</code> field. The winter cleanup maps to the existing cleanup cron, but with a human-facing narrative: it is not automated garbage collection, it is a season of release.
  </p>
  <p>
    The harder question is how to compute plant position and clustering. One approach: use the embedding vectors that deja already stores for semantic matching. Run a dimensionality reduction (UMAP or t-SNE) on the embedding space and map the results to a 2D garden layout. Semantically related memories would cluster together naturally, making the garden not just a health dashboard but a topology of knowledge.
  </p>

  <h2 id="design-tensions">Design tensions</h2>
  <p>
    The obvious tension is between metaphor and utility. Gardens are beautiful. They invite care. But they can also obscure the very data they are meant to reveal. When a user needs to find a specific memory, scrolling through an animated garden is slower than searching a table. When a user needs to bulk-update confidence values, clicking individual plants is worse than selecting rows.
  </p>
  <p>
    This is the tension every skeuomorphic interface faces: the metaphor is the value and the limit. The garden works when the task is "understand the health of my memory" or "spend five minutes maintaining what I know." It fails when the task is "find the memory about the Postgres connection string" or "export all memories as JSON."
  </p>
  <p>
    The resolution is not to choose one or the other but to layer them. The garden is a view, not the view. It exists alongside the filing cabinet, the search conversation, and the API. It serves a specific mode of attention -- reflective, spatial, aesthetic -- that the other interfaces do not.
  </p>
  <p>
    Another tension: animation and motion. The swaying plants, the glowing halos, the wilting transitions -- these are part of the emotional experience. But they are also visual noise. Too much motion and the garden becomes a screensaver, not a tool. The design must calibrate motion to meaning: sway indicates life, stillness indicates dormancy, and nothing moves without reason.
  </p>

  <h2 id="philosophical-note">Philosophical note</h2>
  <p>
    There is a meaningful difference between care and janitorial work. Both involve maintaining a system. But care implies relationship. You care for something you value. You clean something you tolerate. The filing cabinet invites janitorial attention: scan, sort, delete, move on. The garden invites care: notice, consider, tend, return.
  </p>
  <p>
    This distinction matters for a memory system because the quality of human attention shapes the quality of the memory. A user who approaches their agent's knowledge as a chore will make different decisions than one who approaches it as a practice. The former will delete aggressively and move on. The latter will notice that a wilting memory might just need reinforcement, or that two memories near each other might benefit from being merged into a more nuanced understanding.
  </p>
  <p>
    The best memory systems in nature -- human brains, ecosystems, oral traditions -- all involve active tending. They do not persist passively. They require attention, repetition, pruning, and seasonal rhythms. The decay garden is an argument that artificial memory systems should work the same way. Not because the metaphor is clever, but because the underlying dynamics are the same.
  </p>
</ResearchLayout>

<style>
  .garden-grid {
    min-height: 260px;
  }

  .plant-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .plant-container:hover {
    transform: scale(1.08);
  }

  .plant-stem {
    width: 2px;
    background: linear-gradient(to top, var(--stem-color), var(--stem-color-light));
    border-radius: 1px;
    transform-origin: bottom center;
    animation: plant-sway var(--sway-duration, 4s) ease-in-out infinite alternate;
    position: relative;
  }

  .plant-leaf {
    position: absolute;
    width: var(--leaf-size, 8px);
    height: var(--leaf-size, 8px);
    border-radius: 0 50% 50% 50%;
    background: var(--leaf-color);
    opacity: var(--leaf-opacity, 0.7);
  }

  .plant-leaf.left {
    left: -2px;
    transform: translateX(-100%) rotate(-45deg);
  }

  .plant-leaf.right {
    right: -2px;
    transform: translateX(100%) rotate(45deg);
  }

  .plant-glow {
    width: var(--glow-size, 16px);
    height: var(--glow-size, 16px);
    border-radius: 50%;
    background: radial-gradient(circle, var(--glow-color) 0%, transparent 70%);
    animation: plant-pulse var(--pulse-duration, 3s) ease-in-out infinite alternate;
    margin-bottom: -4px;
  }

  .plant-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--label-color, rgba(184, 184, 184, 0.4));
    text-align: center;
    margin-top: 6px;
    max-width: 80px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    line-height: 1.2;
  }

  .plant-confidence {
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px;
    color: var(--confidence-color, rgba(184, 184, 184, 0.3));
    text-align: center;
    margin-top: 1px;
  }

  .plant-ground {
    width: 20px;
    height: 3px;
    border-radius: 1px;
    background: var(--ground-color, rgba(201, 169, 97, 0.15));
    margin-top: 2px;
  }

  @keyframes plant-sway {
    0% { transform: rotate(-2deg); }
    100% { transform: rotate(2deg); }
  }

  @keyframes plant-pulse {
    0% { opacity: 0.6; transform: scale(0.95); }
    100% { opacity: 1; transform: scale(1.05); }
  }

  .plant-wilting .plant-stem {
    animation: plant-wilt 5s ease-in-out infinite alternate;
  }

  @keyframes plant-wilt {
    0% { transform: rotate(-6deg); }
    100% { transform: rotate(-3deg); }
  }

  .plant-critical {
    opacity: 0.3;
  }

  .plant-critical .plant-stem {
    animation: none;
  }

  .plant-removed {
    animation: plant-fade-out 0.5s ease-out forwards;
  }

  @keyframes plant-fade-out {
    to {
      opacity: 0;
      transform: scale(0.5) translateY(20px);
    }
  }

  .plant-watered {
    animation: plant-water-flash 0.6s ease-out;
  }

  @keyframes plant-water-flash {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.5); }
    100% { filter: brightness(1); }
  }
</style>

<script>
  const memories = [
    { id: 1, trigger: 'deploy dry-run', learning: 'Always run --dry-run before production deploys to catch configuration issues early', confidence: 0.95, scope: 'shared', lastRecalled: '2 days ago', recallCount: 12 },
    { id: 2, trigger: 'pg connection pool', learning: 'Set max pool size to 20 for production, 5 for staging to avoid connection exhaustion', confidence: 0.88, scope: 'agent', lastRecalled: '1 week ago', recallCount: 8 },
    { id: 3, trigger: 'error boundaries', learning: 'Wrap async route handlers in error boundaries to prevent unhandled promise rejections crashing the process', confidence: 0.82, scope: 'shared', lastRecalled: '3 days ago', recallCount: 6 },
    { id: 4, trigger: 'migration order', learning: 'Run migrations before deploying new code, not after, to avoid schema mismatch errors', confidence: 0.75, scope: 'agent', lastRecalled: '2 weeks ago', recallCount: 4 },
    { id: 5, trigger: 'cache invalidation', learning: 'Invalidate CDN cache after deploying static assets using the purge endpoint', confidence: 0.70, scope: 'session', lastRecalled: '3 weeks ago', recallCount: 3 },
    { id: 6, trigger: 'env var naming', learning: 'Prefix all environment variables with APP_ to avoid conflicts with system variables', confidence: 0.65, scope: 'shared', lastRecalled: '1 month ago', recallCount: 5 },
    { id: 7, trigger: 'rate limiting', learning: 'Apply rate limiting at the API gateway level, not in application code, for consistent behavior', confidence: 0.58, scope: 'agent', lastRecalled: '2 months ago', recallCount: 2 },
    { id: 8, trigger: 'log levels', learning: 'Use structured JSON logging in production and pretty-print in development', confidence: 0.52, scope: 'session', lastRecalled: '6 weeks ago', recallCount: 2 },
    { id: 9, trigger: 'docker layer cache', learning: 'Order Dockerfile commands from least to most frequently changed to maximize layer caching', confidence: 0.45, scope: 'agent', lastRecalled: '2 months ago', recallCount: 1 },
    { id: 10, trigger: 'test fixtures', learning: 'Use factory functions instead of static fixtures for test data to keep tests independent', confidence: 0.40, scope: 'session', lastRecalled: '3 months ago', recallCount: 1 },
    { id: 11, trigger: 'branch naming', learning: 'Use feat/ fix/ chore/ prefixes for branch names to trigger correct CI pipelines', confidence: 0.32, scope: 'agent', lastRecalled: '3 months ago', recallCount: 1 },
    { id: 12, trigger: 'websocket auth', learning: 'Authenticate WebSocket connections on the initial handshake, not on first message', confidence: 0.28, scope: 'session', lastRecalled: '4 months ago', recallCount: 0 },
    { id: 13, trigger: 'css specificity', learning: 'Avoid nesting selectors more than 3 levels deep to keep specificity manageable', confidence: 0.22, scope: 'session', lastRecalled: '5 months ago', recallCount: 0 },
    { id: 14, trigger: 'npm audit', learning: 'Run npm audit weekly and address critical vulnerabilities within 48 hours', confidence: 0.15, scope: 'agent', lastRecalled: '6 months ago', recallCount: 0 },
    { id: 15, trigger: 'svg optimization', learning: 'Use SVGO to optimize SVG files before committing to reduce bundle size by up to 30%', confidence: 0.10, scope: 'session', lastRecalled: '7 months ago', recallCount: 0 },
  ];

  let selectedId: number | null = null;

  function getPlantColors(confidence: number) {
    if (confidence >= 0.8) {
      return {
        stem: '#9b7e3c',
        stemLight: '#c9a961',
        leaf: 'rgba(201, 169, 97, 0.6)',
        leafOpacity: 0.8,
        glow: 'rgba(201, 169, 97, 0.5)',
        label: 'rgba(201, 169, 97, 0.7)',
        confidence: 'rgba(201, 169, 97, 0.6)',
        ground: 'rgba(201, 169, 97, 0.25)',
      };
    } else if (confidence >= 0.5) {
      return {
        stem: '#6b5c38',
        stemLight: '#8b7a50',
        leaf: 'rgba(160, 140, 90, 0.4)',
        leafOpacity: 0.5,
        glow: 'rgba(160, 140, 90, 0.25)',
        label: 'rgba(184, 184, 184, 0.5)',
        confidence: 'rgba(184, 184, 184, 0.4)',
        ground: 'rgba(201, 169, 97, 0.15)',
      };
    } else if (confidence >= 0.2) {
      return {
        stem: '#4a4a4a',
        stemLight: '#5a5a5a',
        leaf: 'rgba(100, 100, 100, 0.3)',
        leafOpacity: 0.3,
        glow: 'rgba(100, 100, 100, 0.15)',
        label: 'rgba(184, 184, 184, 0.3)',
        confidence: 'rgba(184, 184, 184, 0.25)',
        ground: 'rgba(100, 100, 100, 0.15)',
      };
    } else {
      return {
        stem: '#2a2a2a',
        stemLight: '#3a3a3a',
        leaf: 'rgba(60, 60, 60, 0.2)',
        leafOpacity: 0.15,
        glow: 'rgba(60, 60, 60, 0.08)',
        label: 'rgba(184, 184, 184, 0.15)',
        confidence: 'rgba(184, 184, 184, 0.12)',
        ground: 'rgba(60, 60, 60, 0.1)',
      };
    }
  }

  function renderGarden() {
    const garden = document.querySelector('.garden-grid')!;
    garden.innerHTML = '';

    memories.forEach((mem, i) => {
      const colors = getPlantColors(mem.confidence);
      const stemHeight = Math.max(20, mem.confidence * 120);
      const glowSize = Math.max(6, mem.confidence * 24);
      const leafSize = Math.max(4, mem.confidence * 12);
      const swayDuration = 3 + Math.random() * 3;
      const pulseDuration = 2.5 + Math.random() * 2;
      const stateClass = mem.confidence < 0.2 ? 'plant-critical' : mem.confidence < 0.5 ? 'plant-wilting' : '';

      const leafCount = mem.confidence >= 0.8 ? 3 : mem.confidence >= 0.5 ? 2 : mem.confidence >= 0.2 ? 1 : 0;
      let leavesHtml = '';
      for (let l = 0; l < leafCount; l++) {
        const yPos = 30 + l * 25;
        const side = l % 2 === 0 ? 'left' : 'right';
        leavesHtml += `<div class="plant-leaf ${side}" style="--leaf-size: ${leafSize}px; --leaf-color: ${colors.leaf}; --leaf-opacity: ${colors.leafOpacity}; bottom: ${yPos}%;"></div>`;
      }

      const plant = document.createElement('div');
      plant.className = `plant-container ${stateClass}`;
      plant.dataset.id = String(mem.id);
      plant.style.setProperty('--sway-duration', `${swayDuration}s`);
      plant.style.setProperty('--pulse-duration', `${pulseDuration}s`);
      plant.innerHTML = `
        <div class="plant-glow" style="--glow-size: ${glowSize}px; --glow-color: ${colors.glow};"></div>
        <div class="plant-stem" style="height: ${stemHeight}px; --stem-color: ${colors.stem}; --stem-color-light: ${colors.stemLight}; --sway-duration: ${swayDuration}s;">
          ${leavesHtml}
        </div>
        <div class="plant-ground" style="--ground-color: ${colors.ground};"></div>
        <div class="plant-label" style="--label-color: ${colors.label};">${mem.trigger}</div>
        <div class="plant-confidence" style="--confidence-color: ${colors.confidence};">${mem.confidence.toFixed(2)}</div>
      `;

      plant.addEventListener('mouseenter', () => showDetail(mem.id));
      plant.addEventListener('click', () => selectPlant(mem.id));
      garden.appendChild(plant);
    });

    updateStats();
  }

  function showDetail(id: number) {
    const mem = memories.find(m => m.id === id);
    if (!mem) return;
    const panel = document.getElementById('plant-detail')!;
    panel.classList.remove('hidden');
    document.getElementById('detail-trigger')!.textContent = mem.trigger;
    document.getElementById('detail-learning')!.textContent = mem.learning;
    const confEl = document.getElementById('detail-confidence')!;
    confEl.textContent = `confidence: ${mem.confidence.toFixed(2)}`;
    confEl.style.color = mem.confidence >= 0.7 ? '#c9a961' : mem.confidence >= 0.4 ? '#8b7a50' : '#666';
    document.getElementById('detail-recalled')!.textContent = `recalled: ${mem.lastRecalled} (${mem.recallCount}x)`;
    document.getElementById('detail-scope')!.textContent = `scope: ${mem.scope}`;
    selectedId = id;
  }

  function selectPlant(id: number) {
    selectedId = id;
    showDetail(id);
  }

  function updateStats() {
    const alive = memories.filter(m => m.confidence >= 0.3).length;
    const total = memories.length;
    const avgConf = memories.reduce((s, m) => s + m.confidence, 0) / total;
    document.getElementById('garden-stats')!.textContent = `${alive} healthy / ${total} total -- avg confidence: ${avgConf.toFixed(2)}`;
  }

  document.getElementById('water-btn')?.addEventListener('click', () => {
    if (selectedId === null) return;
    const mem = memories.find(m => m.id === selectedId);
    if (!mem) return;
    mem.confidence = Math.min(1.0, mem.confidence + 0.1);
    const plant = document.querySelector(`.plant-container[data-id="${selectedId}"]`) as HTMLElement;
    if (plant) {
      plant.classList.add('plant-watered');
      setTimeout(() => plant.classList.remove('plant-watered'), 600);
    }
    renderGarden();
    showDetail(selectedId);
  });

  document.getElementById('prune-btn')?.addEventListener('click', () => {
    if (selectedId === null) return;
    const idx = memories.findIndex(m => m.id === selectedId);
    if (idx === -1) return;
    const plant = document.querySelector(`.plant-container[data-id="${selectedId}"]`) as HTMLElement;
    if (plant) {
      plant.classList.add('plant-removed');
      setTimeout(() => {
        memories.splice(idx, 1);
        selectedId = null;
        document.getElementById('plant-detail')!.classList.add('hidden');
        renderGarden();
      }, 500);
    }
  });

  document.getElementById('transplant-btn')?.addEventListener('click', () => {
    if (selectedId === null) return;
    const mem = memories.find(m => m.id === selectedId);
    if (!mem) return;
    const scopes = ['session', 'agent', 'shared'];
    const currentIdx = scopes.indexOf(mem.scope);
    mem.scope = scopes[(currentIdx + 1) % scopes.length];
    showDetail(selectedId);
  });

  document.getElementById('winter-btn')?.addEventListener('click', () => {
    const seasonLabel = document.getElementById('season-label')!;
    seasonLabel.textContent = 'Winter';
    seasonLabel.style.color = '#666';

    const toRemove = memories.filter(m => m.confidence < 0.3);
    toRemove.forEach(mem => {
      const plant = document.querySelector(`.plant-container[data-id="${mem.id}"]`) as HTMLElement;
      if (plant) plant.classList.add('plant-removed');
    });

    setTimeout(() => {
      for (let i = memories.length - 1; i >= 0; i--) {
        if (memories[i].confidence < 0.3) memories.splice(i, 1);
      }
      selectedId = null;
      document.getElementById('plant-detail')!.classList.add('hidden');
      renderGarden();

      setTimeout(() => {
        seasonLabel.textContent = 'Spring';
        seasonLabel.style.color = '#c9a961';
      }, 1500);
    }, 600);
  });

  renderGarden();
</script>
