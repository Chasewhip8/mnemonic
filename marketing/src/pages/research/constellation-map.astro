---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('constellation-map')!;
---

<ResearchLayout concept={concept}>
  <!-- Demo -->
  <div slot="demo">
    <div class="cm-demo bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10 bg-steel/50">
        <div class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/60">Knowledge Topology</div>
        <div class="flex items-center gap-4">
          <!-- Legend -->
          <div class="flex items-center gap-3">
            <div class="flex items-center gap-1.5">
              <span class="inline-block w-[7px] h-[7px] rounded-full bg-[#c9a961]"></span>
              <span class="font-mono text-[9px] text-chrome-dark/40">Shared</span>
            </div>
            <div class="flex items-center gap-1.5">
              <span class="inline-block w-[7px] h-[7px] rounded-full bg-[#60a5fa]"></span>
              <span class="font-mono text-[9px] text-chrome-dark/40">Agent</span>
            </div>
            <div class="flex items-center gap-1.5">
              <span class="inline-block w-[7px] h-[7px] rounded-full bg-[#555]"></span>
              <span class="font-mono text-[9px] text-chrome-dark/40">Session</span>
            </div>
          </div>
          <div class="font-mono text-[10px] text-chrome-dark/25">scroll to zoom / drag to pan</div>
        </div>
      </div>

      <!-- Canvas -->
      <div class="relative" style="height: 420px;">
        <canvas id="cm-canvas" class="w-full h-full" style="cursor: grab;"></canvas>
        <!-- Tooltip -->
        <div id="cm-tooltip" class="cm-tooltip hidden">
          <div class="font-mono text-[9px] text-brass/60 uppercase tracking-wider mb-0.5" id="cm-tooltip-scope"></div>
          <div class="font-serif text-[12px] text-chrome/80 leading-snug" id="cm-tooltip-text"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ToC -->
  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#the-deeper-idea" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The deeper idea</a>
  </Fragment>

  <!-- Content -->
  <h2 id="the-experience">The experience</h2>

  <p>You see stars. Not a list, not a table, not a timeline -- a field of small luminous points scattered across a dark canvas. Each point is a memory. Their positions are not random. Memories that are semantically similar cluster together, drawn close by the gravity of shared meaning. Memories that are unrelated drift apart.</p>

  <p>Four clusters are immediately visible. On the left, a dense constellation of eight or nine nodes labeled "Deployment" -- gold and blue dots packed tightly, connected by faint lines that indicate high cosine similarity. This is where your agent knows the most. The density is itself information: you have deep knowledge here, multiple overlapping memories reinforcing and sometimes contradicting each other.</p>

  <p>Above and to the right, a smaller cluster: "Testing." Five or six nodes, slightly more spread out, suggesting the knowledge is related but not as tightly integrated. Below, "Monitoring" is sparser still -- three nodes with longer edges between them, forming a loose triangle rather than a tight cluster. And in the far corner, two isolated points labeled "Security," barely connected to anything. These are the orphans: memories stored but unintegrated, knowledge without context.</p>

  <p>You hover over a node and a tooltip appears: the trigger text of that memory, its scope, its confidence. You drag a node and the physics engine responds -- connected nodes follow, stretching and rebounding like a web. You scroll to zoom in on the deployment cluster and see the individual connections: which memories are similar to which, how tightly they are linked. You scroll out and the whole topology is visible again. The shape of everything you know, rendered as geometry.</p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>The constellation map reveals topology. It answers a question that no other interface even asks: what is the <em>shape</em> of your knowledge?</p>

  <p>Shape has several dimensions. Density tells you where you have depth -- many memories, tightly clustered, covering the same territory from multiple angles. Sparsity tells you where you have breadth without depth -- a few isolated memories that touch a topic but do not cover it. And the empty space between clusters, the void where no stars exist, tells you what you do not know at all.</p>

  <p>This last property is the most valuable. Most interfaces can only show you what exists. The filing cabinet shows rows. The journal shows events. The search conversation shows answers. They all require something to be there. The constellation map shows the negative space. If you have a dense deployment cluster and a dense testing cluster but nothing between them -- no memories about deployment testing, about testing in production, about the intersection of the two -- that gap is visible as empty space on the map. The unknown becomes a visible region.</p>

  <p>The map also reveals scope distribution through color. If your deployment cluster is mostly gold (shared scope), that knowledge is organizational -- it has been validated and promoted. If your testing cluster is mostly blue (agent-specific), that knowledge is local -- one agent's experience that has not been vetted. If scattered gray dots (session scope) appear at the periphery, those are ephemeral memories that were never promoted. The color distribution within a cluster tells you about the maturity of your knowledge in that domain.</p>

  <p>Edge density reveals interconnection. Two clusters with many edges between them have cross-domain knowledge -- memories that bridge topics. Two clusters with no edges between them are siloed. The topology of edges is a map of how your knowledge is (or is not) integrated.</p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>The constellation map is built from deja's existing embedding infrastructure. Every memory stored in deja gets a 384-dimension embedding vector computed by the embedding model and stored in Cloudflare Vectorize. These vectors encode semantic meaning: memories about similar topics have vectors that point in similar directions. Cosine similarity between any two vectors tells you how related they are.</p>

  <p>The challenge is projection. 384 dimensions cannot be rendered on a 2D screen. The standard approach is to use a dimensionality reduction algorithm -- UMAP (Uniform Manifold Approximation and Projection) or t-SNE (t-distributed Stochastic Neighbor Embedding) -- to project the high-dimensional embeddings down to two coordinates while preserving local structure. UMAP is generally preferred for this use case because it better preserves the global topology: clusters that are far apart in 384 dimensions remain far apart in 2D.</p>

  <p>The projection can happen server-side or client-side. For small knowledge bases (under a few hundred memories), client-side UMAP via a JavaScript library like <code>umap-js</code> is fast enough. For larger collections, pre-computing the 2D coordinates server-side and caching them makes more sense. The coordinates only need to be recomputed when new memories are added or existing ones change.</p>

  <p>Edges are derived from cosine similarity. For each memory, compute the cosine similarity to every other memory. Draw an edge when the similarity exceeds a threshold -- say, 0.7. The threshold is tunable and has a significant effect on the visual density of the graph. Too low, and every node connects to every other node. Too high, and no edges appear. A good default is somewhere between 0.65 and 0.75, with a slider letting the user adjust in real time.</p>

  <p>Cluster labels are a harder problem. You can detect clusters algorithmically using DBSCAN or k-means on the 2D projected coordinates, but generating meaningful labels requires understanding the semantic content of each cluster. One approach: for each cluster, extract the most common keywords from the trigger texts of its members. Another: pass the triggers to an LLM and ask for a one-word summary. The latter produces better labels but introduces a dependency on a language model.</p>

  <h2 id="design-tensions">Design tensions</h2>

  <p>The constellation map is beautiful and informative, but it is also fundamentally passive. You look at it. You see the shape. You notice the gaps. And then what? Clicking a node shows you the memory, but you are now back to a tooltip -- a tiny filing cabinet. The map is an observation tool, not an action tool. It tells you where to look but does not help you do anything about what you find.</p>

  <p>The actionable version of the constellation map would need affordances for intervention. Select a sparse region and ask "what should I learn about this?" Select a dense cluster and ask "are there contradictions here?" Draw a line between two disconnected clusters and ask "what connects these?" Each of these actions turns the map from a visualization into an interface -- a way of interacting with knowledge through its topology rather than its content.</p>

  <p>There is also a fidelity problem. Dimensionality reduction is lossy. When you project from 384 dimensions to 2, you inevitably distort some relationships. Two memories that are close in high-dimensional space might end up far apart in 2D, and vice versa. The map is not the territory. Users who do not understand this will make incorrect inferences from the layout. The map needs a way to communicate its own limitations -- perhaps by showing the projection error as a visual uncertainty, or by letting users query the actual similarity between any two nodes.</p>

  <p>Scale is a practical concern. The constellation map works well with tens or hundreds of nodes. At thousands, the canvas becomes crowded, the physics simulation becomes slow, and the visual clusters overlap. Level-of-detail rendering -- showing cluster summaries when zoomed out and individual nodes when zoomed in -- is the standard solution, but it adds significant implementation complexity. The simple version of this interface has a natural ceiling around 500 memories before the visualization becomes more confusing than helpful.</p>

  <h2 id="the-deeper-idea">The deeper idea</h2>

  <p>The constellation map is the beginning of something larger: organizational knowledge diagnostics.</p>

  <p>Most organizations do not know what they know. Individual engineers hold knowledge in their heads, in documents, in Slack threads, in code comments. No one has a map of the whole. The constellation map, applied across a team's shared memory scope, would make the collective knowledge structure visible for the first time. Where does the team have expertise? Where are the blind spots? Which domains are well-covered by multiple agents and which depend on a single agent's memory?</p>

  <p>This is not an academic exercise. Blind spots in organizational knowledge cause incidents. If no agent has strong memories about database failover, and you have a database failover, the response will be slower and more error-prone than it would be if the knowledge existed. The constellation map makes this risk visible before the incident happens. The empty space on the map is where your next outage will hurt most.</p>

  <p>The deeper idea is that the shape of knowledge is predictive. Dense clusters correlate with competence. Sparse regions correlate with risk. Disconnected clusters correlate with silos -- teams that know things but do not share them. The map is not just a visualization of the present. It is a leading indicator of the future.</p>

  <p>Imagine a quarterly review where instead of reading status reports, leadership looks at the constellation map and asks: "Why is the security cluster so sparse? Why is there no connection between deployment and monitoring? Why do we have 47 memories about CI configuration but only 3 about incident response?" These are the right questions. The constellation map is the only interface in this series that provokes them.</p>

  <p>The filing cabinet tells you what you know. The journal tells you when you learned it. The search conversation tells you what it means. The constellation map tells you what shape your knowledge has -- and more importantly, what shape it does not. That negative space, the visible absence, is the most important thing a memory interface can show you. Because the memories you have are the memories you have. The ones you are missing are the ones that will cost you.</p>
</ResearchLayout>

<style>
  .cm-demo {
    font-family: var(--font-mono), monospace;
  }

  .cm-tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(5, 5, 5, 0.92);
    border: 1px solid rgba(201, 169, 97, 0.2);
    border-radius: 3px;
    padding: 8px 12px;
    max-width: 240px;
    z-index: 10;
    backdrop-filter: blur(4px);
  }

  #cm-canvas {
    display: block;
  }
</style>

<script>
  interface Node {
    x: number;
    y: number;
    vx: number;
    vy: number;
    radius: number;
    scope: 'shared' | 'agent' | 'session';
    cluster: string;
    trigger: string;
    pinned: boolean;
  }

  interface Edge {
    source: number;
    target: number;
    strength: number;
  }

  const canvas = document.getElementById('cm-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;
  const tooltip = document.getElementById('cm-tooltip') as HTMLDivElement;
  const tooltipScope = document.getElementById('cm-tooltip-scope') as HTMLDivElement;
  const tooltipText = document.getElementById('cm-tooltip-text') as HTMLDivElement;

  let width = 0;
  let height = 0;
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;
  let dragging: number | null = null;
  let panning = false;
  let panStartX = 0;
  let panStartY = 0;
  let hoveredNode: number | null = null;

  function resize() {
    const rect = canvas.parentElement!.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    width = rect.width;
    height = rect.height;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const clusterCenters: Record<string, { x: number; y: number }> = {
    'Deployment': { x: 0.28, y: 0.45 },
    'Testing': { x: 0.65, y: 0.3 },
    'Monitoring': { x: 0.55, y: 0.7 },
    'Security': { x: 0.85, y: 0.75 },
  };

  const nodeData: Array<{ scope: Node['scope']; cluster: string; trigger: string }> = [
    { scope: 'shared', cluster: 'Deployment', trigger: 'Always dry-run before production deploys' },
    { scope: 'shared', cluster: 'Deployment', trigger: 'Use --no-cache for production Docker builds' },
    { scope: 'shared', cluster: 'Deployment', trigger: 'Pin base images to SHA digests' },
    { scope: 'shared', cluster: 'Deployment', trigger: 'Maintain blue-green for instant rollback' },
    { scope: 'agent', cluster: 'Deployment', trigger: 'Set generous liveness probe initial delay' },
    { scope: 'agent', cluster: 'Deployment', trigger: 'Use expand-contract for DB migrations' },
    { scope: 'shared', cluster: 'Deployment', trigger: 'Identical infra modules for staging and prod' },
    { scope: 'session', cluster: 'Deployment', trigger: 'Skip dry-run for hotfixes with two approvers' },
    { scope: 'agent', cluster: 'Deployment', trigger: 'Tag releases with semver before deploying' },
    { scope: 'agent', cluster: 'Testing', trigger: 'Parallelize test suites by module' },
    { scope: 'agent', cluster: 'Testing', trigger: 'Cache dependency installs in CI' },
    { scope: 'shared', cluster: 'Testing', trigger: 'Never share DB state between test runs' },
    { scope: 'session', cluster: 'Testing', trigger: 'Snapshot tests catch unintended UI changes' },
    { scope: 'agent', cluster: 'Testing', trigger: 'Run integration tests in containers' },
    { scope: 'shared', cluster: 'Testing', trigger: 'Flaky tests must be quarantined immediately' },
    { scope: 'shared', cluster: 'Monitoring', trigger: 'Alert on p99 latency, not averages' },
    { scope: 'agent', cluster: 'Monitoring', trigger: 'Set up dashboards before deploying new services' },
    { scope: 'session', cluster: 'Monitoring', trigger: 'First 48h after deploy need extra monitoring' },
    { scope: 'agent', cluster: 'Monitoring', trigger: 'Error rate spikes correlate with deploy times' },
    { scope: 'shared', cluster: 'Security', trigger: 'Pre-commit hooks to scan for secrets' },
    { scope: 'session', cluster: 'Security', trigger: 'Rotate API keys quarterly' },
    { scope: 'agent', cluster: 'Deployment', trigger: 'Feature flags decouple deploy from release' },
    { scope: 'session', cluster: 'Testing', trigger: 'Load tests should simulate real traffic patterns' },
    { scope: 'agent', cluster: 'Monitoring', trigger: 'Log structured JSON for better querying' },
    { scope: 'shared', cluster: 'Deployment', trigger: 'Canary deploys catch regressions early' },
    { scope: 'agent', cluster: 'Testing', trigger: 'Contract tests for API boundaries' },
  ];

  const nodes: Node[] = nodeData.map(d => {
    const center = clusterCenters[d.cluster];
    const spread = d.cluster === 'Security' ? 0.06 : d.cluster === 'Monitoring' ? 0.07 : 0.06;
    return {
      x: center.x + (Math.random() - 0.5) * spread * 2,
      y: center.y + (Math.random() - 0.5) * spread * 2,
      vx: 0,
      vy: 0,
      radius: d.scope === 'shared' ? 5 : d.scope === 'agent' ? 4 : 3.5,
      scope: d.scope,
      cluster: d.cluster,
      trigger: d.trigger,
      pinned: false,
    };
  });

  const edges: Edge[] = [];
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const sameCluster = nodes[i].cluster === nodes[j].cluster;
      if (sameCluster && Math.random() < 0.55) {
        edges.push({ source: i, target: j, strength: 0.6 + Math.random() * 0.3 });
      } else if (!sameCluster && Math.random() < 0.03) {
        edges.push({ source: i, target: j, strength: 0.2 + Math.random() * 0.2 });
      }
    }
  }

  const scopeColors: Record<string, string> = {
    shared: '#c9a961',
    agent: '#60a5fa',
    session: '#555555',
  };

  const scopeGlow: Record<string, string> = {
    shared: 'rgba(201, 169, 97, 0.3)',
    agent: 'rgba(96, 165, 250, 0.3)',
    session: 'rgba(85, 85, 85, 0.2)',
  };

  function toScreen(nx: number, ny: number): [number, number] {
    return [nx * width * scale + offsetX, ny * height * scale + offsetY];
  }

  function fromScreen(sx: number, sy: number): [number, number] {
    return [(sx - offsetX) / (width * scale), (sy - offsetY) / (height * scale)];
  }

  function simulate() {
    const damping = 0.92;
    const repulsion = 0.0004;
    const springLength = 0.04;
    const springForce = 0.008;
    const centerGravity = 0.0001;

    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].pinned) continue;
      let fx = 0;
      let fy = 0;

      for (let j = 0; j < nodes.length; j++) {
        if (i === j) continue;
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
        const force = repulsion / (dist * dist);
        fx += (dx / dist) * force;
        fy += (dy / dist) * force;
      }

      fx += (0.5 - nodes[i].x) * centerGravity;
      fy += (0.5 - nodes[i].y) * centerGravity;

      nodes[i].vx = (nodes[i].vx + fx) * damping;
      nodes[i].vy = (nodes[i].vy + fy) * damping;
    }

    for (const edge of edges) {
      const a = nodes[edge.source];
      const b = nodes[edge.target];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
      const displacement = dist - springLength;
      const force = displacement * springForce * edge.strength;
      const fx = (dx / dist) * force;
      const fy = (dy / dist) * force;

      if (!a.pinned) { a.vx += fx; a.vy += fy; }
      if (!b.pinned) { b.vx -= fx; b.vy -= fy; }
    }

    for (const node of nodes) {
      if (node.pinned) continue;
      node.x += node.vx;
      node.y += node.vy;
      node.x = Math.max(0.05, Math.min(0.95, node.x));
      node.y = Math.max(0.05, Math.min(0.95, node.y));
    }
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    for (const edge of edges) {
      const [x1, y1] = toScreen(nodes[edge.source].x, nodes[edge.source].y);
      const [x2, y2] = toScreen(nodes[edge.target].x, nodes[edge.target].y);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = `rgba(201, 169, 97, ${0.04 + edge.strength * 0.08})`;
      ctx.lineWidth = 0.5 + edge.strength * 0.5;
      ctx.stroke();
    }

    const clusterPositions: Record<string, { sumX: number; sumY: number; count: number }> = {};
    for (const node of nodes) {
      if (!clusterPositions[node.cluster]) {
        clusterPositions[node.cluster] = { sumX: 0, sumY: 0, count: 0 };
      }
      clusterPositions[node.cluster].sumX += node.x;
      clusterPositions[node.cluster].sumY += node.y;
      clusterPositions[node.cluster].count++;
    }

    ctx.font = '9px JetBrains Mono, monospace';
    ctx.textAlign = 'center';
    for (const [label, pos] of Object.entries(clusterPositions)) {
      const [lx, ly] = toScreen(pos.sumX / pos.count, pos.sumY / pos.count - 0.06);
      ctx.fillStyle = 'rgba(201, 169, 97, 0.2)';
      ctx.fillText(label.toUpperCase(), lx, ly);
    }

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const [sx, sy] = toScreen(node.x, node.y);
      const isHovered = hoveredNode === i;
      const r = node.radius * (isHovered ? 1.6 : 1) * scale;

      if (isHovered || node.scope === 'shared') {
        ctx.beginPath();
        ctx.arc(sx, sy, r + (isHovered ? 8 : 4), 0, Math.PI * 2);
        ctx.fillStyle = isHovered ? scopeGlow[node.scope] : scopeGlow[node.scope].replace('0.3', '0.08').replace('0.2', '0.04');
        ctx.fill();
      }

      ctx.beginPath();
      ctx.arc(sx, sy, r, 0, Math.PI * 2);
      ctx.fillStyle = scopeColors[node.scope];
      ctx.globalAlpha = isHovered ? 1 : (node.scope === 'session' ? 0.5 : 0.8);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function loop() {
    simulate();
    draw();
    requestAnimationFrame(loop);
  }

  function getMousePos(e: MouseEvent): [number, number] {
    const rect = canvas.getBoundingClientRect();
    return [e.clientX - rect.left, e.clientY - rect.top];
  }

  function findNodeAt(mx: number, my: number): number | null {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const [sx, sy] = toScreen(nodes[i].x, nodes[i].y);
      const r = nodes[i].radius * 2 * scale;
      const dx = mx - sx;
      const dy = my - sy;
      if (dx * dx + dy * dy < r * r) return i;
    }
    return null;
  }

  canvas.addEventListener('mousedown', (e) => {
    const [mx, my] = getMousePos(e);
    const nodeIdx = findNodeAt(mx, my);
    if (nodeIdx !== null) {
      dragging = nodeIdx;
      nodes[nodeIdx].pinned = true;
      canvas.style.cursor = 'grabbing';
    } else {
      panning = true;
      panStartX = mx - offsetX;
      panStartY = my - offsetY;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const [mx, my] = getMousePos(e);

    if (dragging !== null) {
      const [nx, ny] = fromScreen(mx, my);
      nodes[dragging].x = nx;
      nodes[dragging].y = ny;
      nodes[dragging].vx = 0;
      nodes[dragging].vy = 0;
    } else if (panning) {
      offsetX = mx - panStartX;
      offsetY = my - panStartY;
    } else {
      const nodeIdx = findNodeAt(mx, my);
      hoveredNode = nodeIdx;

      if (nodeIdx !== null) {
        canvas.style.cursor = 'pointer';
        const node = nodes[nodeIdx];
        tooltipScope.textContent = node.scope + ' / ' + node.cluster;
        tooltipText.textContent = node.trigger;
        tooltip.classList.remove('hidden');

        const [sx, sy] = toScreen(node.x, node.y);
        let tx = sx + 12;
        let ty = sy - 10;
        if (tx + 250 > width) tx = sx - 250;
        if (ty < 10) ty = sy + 20;
        tooltip.style.left = tx + 'px';
        tooltip.style.top = ty + 'px';
      } else {
        canvas.style.cursor = 'grab';
        tooltip.classList.add('hidden');
      }
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (dragging !== null) {
      nodes[dragging].pinned = false;
      dragging = null;
    }
    panning = false;
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredNode = null;
    tooltip.classList.add('hidden');
    if (dragging !== null) {
      nodes[dragging].pinned = false;
      dragging = null;
    }
    panning = false;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const [mx, my] = getMousePos(e);
    const zoomFactor = e.deltaY > 0 ? 0.92 : 1.08;
    const newScale = Math.max(0.5, Math.min(3, scale * zoomFactor));

    offsetX = mx - (mx - offsetX) * (newScale / scale);
    offsetY = my - (my - offsetY) * (newScale / scale);
    scale = newScale;
  }, { passive: false });

  resize();
  window.addEventListener('resize', resize);
  loop();
</script>
