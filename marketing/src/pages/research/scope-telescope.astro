---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('scope-telescope')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="telescope-container border border-brass/20 rounded-sm bg-void-deep overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10 bg-steel/30">
        <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass">Scope Telescope</span>
        <span class="font-mono text-[10px] text-chrome-dark/30" id="current-scope-label">session:run-2024-02-18</span>
      </div>

      <!-- Zoom Slider -->
      <div class="px-6 py-4 border-b border-brass/10 bg-steel/20">
        <div class="flex items-center justify-between mb-2">
          <span class="font-mono text-[9px] font-bold tracking-widest uppercase text-chrome-dark/30">Zoom Level</span>
        </div>
        <div class="flex items-center gap-4">
          <span class="scope-label session-label font-mono text-[10px] font-bold text-brass">Session</span>
          <div class="flex-1 relative">
            <input type="range" id="zoom-slider" min="0" max="100" value="0" class="zoom-range" />
            <div class="slider-track">
              <div class="slider-tick" style="left: 0%"></div>
              <div class="slider-tick" style="left: 50%"></div>
              <div class="slider-tick" style="left: 100%"></div>
            </div>
          </div>
          <span class="scope-label shared-label font-mono text-[10px] text-chrome-dark/30">Shared</span>
        </div>
        <div class="flex justify-between mt-1 px-10">
          <span class="font-mono text-[8px] text-chrome-dark/20">detailed</span>
          <span class="font-mono text-[8px] text-chrome-dark/20">patterns</span>
          <span class="font-mono text-[8px] text-chrome-dark/20">universal</span>
        </div>
      </div>

      <!-- Memory Views -->
      <div class="telescope-viewport" id="telescope-viewport">
        <!-- SVG Connection Lines -->
        <svg class="connection-lines" id="connection-svg" viewBox="0 0 800 500" preserveAspectRatio="none">
          <!-- Lines drawn by JS -->
        </svg>

        <div class="views-container">
          <!-- Session View -->
          <div class="scope-view" id="view-session" data-opacity="1">
            <div class="scope-header">
              <span class="scope-tag session">session:run-2024-02-18</span>
              <span class="scope-desc">Tactical, specific, ephemeral</span>
            </div>
            <div class="memory-list">
              <div class="memory-item session-item" data-group="1" data-index="0">
                <span class="memory-text">Use --dry-run flag for this specific auth-service deploy on staging-02</span>
                <span class="memory-meta">confidence: 0.92 -- recalled 1 time -- this run only</span>
              </div>
              <div class="memory-item session-item" data-group="2" data-index="1">
                <span class="memory-text">Port 8080 is currently busy on staging-02 due to monitoring sweep</span>
                <span class="memory-meta">confidence: 0.85 -- recalled 2 times -- this run only</span>
              </div>
              <div class="memory-item session-item" data-group="3" data-index="2">
                <span class="memory-text">Migration #47 needs manual review -- auto-migration skipped the session_tokens index</span>
                <span class="memory-meta">confidence: 0.78 -- recalled 1 time -- this run only</span>
              </div>
              <div class="memory-item session-item" data-group="1" data-index="3">
                <span class="memory-text">The auth-service health endpoint returns 503 for 12 seconds after restart</span>
                <span class="memory-meta">confidence: 0.70 -- recalled 1 time -- this run only</span>
              </div>
              <div class="memory-item session-item" data-group="2" data-index="4">
                <span class="memory-text">Redis on staging-02 has 89% memory utilization right now</span>
                <span class="memory-meta">confidence: 0.65 -- recalled 1 time -- expires in 2 hours</span>
              </div>
            </div>
          </div>

          <!-- Transformation Annotation -->
          <div class="transform-annotation" id="annotation-1">
            <div class="annotation-line"></div>
            <span class="annotation-text">specific instances become general patterns</span>
            <div class="annotation-line"></div>
          </div>

          <!-- Agent View -->
          <div class="scope-view" id="view-agent" data-opacity="0.3">
            <div class="scope-header">
              <span class="scope-tag agent">agent:deploy-bot</span>
              <span class="scope-desc">Patterns learned across many runs</span>
            </div>
            <div class="memory-list">
              <div class="memory-item agent-item" data-group="1" data-index="0">
                <span class="memory-text">Always use --dry-run before deploying to staging environments</span>
                <span class="memory-meta">confidence: 0.95 -- recalled 34 times -- learned over 12 runs</span>
              </div>
              <div class="memory-item agent-item" data-group="2" data-index="1">
                <span class="memory-text">Check port availability on staging before binding services</span>
                <span class="memory-meta">confidence: 0.90 -- recalled 28 times -- learned over 8 runs</span>
              </div>
              <div class="memory-item agent-item" data-group="3" data-index="2">
                <span class="memory-text">Always review migration output before proceeding to deploy step</span>
                <span class="memory-meta">confidence: 0.88 -- recalled 19 times -- learned over 6 runs</span>
              </div>
              <div class="memory-item agent-item" data-group="1" data-index="3">
                <span class="memory-text">Wait 15 seconds after restart before running health checks</span>
                <span class="memory-meta">confidence: 0.82 -- recalled 15 times -- learned over 5 runs</span>
              </div>
            </div>
          </div>

          <!-- Transformation Annotation -->
          <div class="transform-annotation" id="annotation-2">
            <div class="annotation-line"></div>
            <span class="annotation-text">agent patterns become organizational truths</span>
            <div class="annotation-line"></div>
          </div>

          <!-- Shared View -->
          <div class="scope-view" id="view-shared" data-opacity="0.15">
            <div class="scope-header">
              <span class="scope-tag shared">shared</span>
              <span class="scope-desc">Universal organizational knowledge</span>
            </div>
            <div class="memory-list">
              <div class="memory-item shared-item" data-group="1" data-index="0">
                <span class="memory-text">Test before you ship. No exceptions.</span>
                <span class="memory-meta">confidence: 0.99 -- recalled 247 times -- 12 endorsements</span>
              </div>
              <div class="memory-item shared-item" data-group="2" data-index="1">
                <span class="memory-text">Monitor every deployment for 30 minutes after release</span>
                <span class="memory-meta">confidence: 0.97 -- recalled 189 times -- 9 endorsements</span>
              </div>
              <div class="memory-item shared-item" data-group="3" data-index="2">
                <span class="memory-text">Document breaking changes before they reach production</span>
                <span class="memory-meta">confidence: 0.96 -- recalled 156 times -- 8 endorsements</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>

  <p>
    A zoom control for memory. At maximum magnification, you see session-level memories -- the tactical, specific, ephemeral facts that belong to a single run. "Port 8080 is busy right now." "Migration #47 needs manual review." These are the memories with the shortest shelf life and the highest specificity. They matter intensely in the moment and barely at all tomorrow.
  </p>
  <p>
    Pull the slider back to the middle position and the view transforms. Session-specific details dissolve and agent-level patterns emerge. "Always check port availability on staging" replaces "Port 8080 is busy right now." The individual incident has been abstracted into a reusable lesson. These agent-scoped memories are more durable, more general, and applicable across many runs. They represent what the agent has learned from repeated experience, not from a single observation.
  </p>
  <p>
    Pull the slider all the way back and you reach the shared scope -- organizational truths. "Test before you ship." "Monitor after every deploy." These are the bedrock beliefs of the entire system, endorsed by multiple agents and humans, recalled hundreds of times. They are not tactical advice. They are principles. The visual treatment reflects this: session memories feel ephemeral and faded, agent memories feel solid, shared memories feel bold and immovable.
  </p>
  <p>
    The connection lines between scopes are the most interesting element. A session memory about dry-running a specific deploy connects visually to the agent pattern "always dry-run before deploying," which connects to the shared truth "test before you ship." The same insight exists at three altitudes, and the telescope makes the relationship between specificity and generality navigable. You can see how a concrete experience became a pattern became a principle.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>
    The telescope reveals the relationship between specificity and generality -- a relationship that is fundamental to how knowledge works but rarely made visible. Every organizational principle started as a specific incident. "Test before you ship" was not always a universal truth. At some point, someone shipped without testing, something broke, and a lesson was learned. That lesson was generalized, validated, and eventually elevated to a principle. The telescope lets you trace this genealogy.
  </p>
  <p>
    This matters because specificity and generality serve different purposes. When you are debugging a failing deploy at 2 AM, you need session-level specificity: which port is conflicting, which migration failed, which health check is timing out. When you are designing a deployment pipeline, you need agent-level patterns: always check ports, always review migrations, always wait after restart. When you are setting policy for the entire engineering organization, you need shared-level principles: test everything, monitor everything, document breaking changes.
  </p>
  <p>
    The telescope also reveals knowledge density at each level. Session scope has many memories but they are individually low-value and short-lived. Agent scope has fewer memories but they are individually higher-value. Shared scope has the fewest memories but the highest value and durability. This inverse relationship -- fewer memories at higher scopes, but each one more valuable -- mirrors how human expertise works. Novices remember specific incidents; experts remember principles.
  </p>
  <p>
    Perhaps most importantly, the telescope reveals gaps. If an agent has strong session memories and strong shared memories but nothing in between, it suggests a failure of abstraction. The agent is accumulating experiences but not learning patterns from them. Conversely, if an agent has strong patterns but no supporting session data, the patterns may be stale or inherited without validation. The telescope makes these structural gaps visible.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>
    Deja already provides the three scope levels that the telescope visualizes: <code>session</code>, <code>agent</code>, and <code>shared</code>. When a learning is stored, its scope determines its visibility and durability. Session learnings are tied to a specific run and may be ephemeral. Agent learnings persist across runs for a specific agent. Shared learnings are visible to all agents and humans on the team. The data model is already there.
  </p>
  <p>
    What deja does not yet do is synthesize abstractions across levels. When a session memory like "port 8080 is busy on staging-02" appears for the third time across different runs, the system should consider promoting an abstracted version -- "check port availability on staging before deploying" -- to agent scope. And when multiple agents independently learn the same pattern, the system should consider proposing a shared learning.
  </p>
  <p>
    The technical implementation would involve a promotion pipeline. After each run, the system compares new session memories against existing agent-scope memories using semantic similarity. If a session memory is a specific instance of an existing pattern, it reinforces that pattern's confidence. If a session memory appears repeatedly without a corresponding agent pattern, the system proposes a new agent-level learning. The same logic applies between agent and shared scopes: when multiple agents hold semantically similar learnings, a shared learning is proposed.
  </p>
  <p>
    The <code>state_resolve</code> mechanism already returns memories from all applicable scopes. The telescope would enhance this by making the scope hierarchy navigable in the UI -- letting humans see what the agent sees at each level and understand why certain memories were recalled. A new <code>GET /learnings?scope=agent&include_origins=true</code> parameter could return agent-level learnings with links to the session memories that generated them, making the abstraction chain auditable.
  </p>

  <h2 id="design-tensions">Design tensions</h2>

  <p>
    <strong>Most memory systems are flat.</strong> They store everything in one undifferentiated pool. Search returns results ranked by relevance, but there is no structural distinction between a tactical fact and a universal principle. This works when the knowledge base is small, but it breaks down at scale. When an agent has thousands of memories, the difference between "port 8080 is busy right now" and "always check port availability" is the difference between noise and signal. The telescope's hierarchy is not just an organizational convenience -- it is a way of managing information overload.
  </p>
  <p>
    <strong>Deja already has three levels. The hard part is making them useful.</strong> Having scopes in the data model is necessary but not sufficient. The telescope interface suggests a way to make the hierarchy legible and navigable: show all three levels simultaneously, with visual connections between related memories. But this raises UX questions. How do you show three levels of memory without overwhelming the viewer? The slider metaphor works in the demo, but in a production environment, users may need to see multiple scopes at once, filter within a scope, or trace a specific memory's genealogy from session to shared.
  </p>
  <p>
    <strong>Automatic abstraction is risky.</strong> Promoting a session memory to an agent pattern involves a judgment call. The session memory "port 8080 is busy on staging-02" might mean "always check port availability" or it might mean "staging-02 has a specific problem that needs fixing." The correct abstraction depends on context that the system may not have. Too-eager promotion leads to over-general patterns that do not actually help. Too-cautious promotion leads to an ever-growing pile of session memories that never become reusable. The right balance probably involves human-in-the-loop review for promotions, at least initially.
  </p>
  <p>
    <strong>Demotion is as important as promotion.</strong> Shared truths can become outdated. "Always deploy to staging before production" might be a strong principle today but irrelevant after a migration to a canary deployment model. The telescope needs to support demotion -- moving a shared learning back to agent scope or archiving it entirely. This is psychologically harder than promotion because it feels like losing knowledge. But a shared scope cluttered with outdated principles is worse than a lean one that reflects current reality. The decay garden concept (explored elsewhere in this research) addresses this directly, but the telescope needs at least a visual indicator of stale shared memories.
  </p>
  <p>
    <strong>The connection lines are the hardest part to implement.</strong> Drawing visual links between related memories at different scopes requires semantic similarity matching across the entire memory hierarchy. In the demo, these connections are hardcoded. In a real system, they would need to be computed dynamically, and the results would need to be presented in a way that is informative rather than chaotic. A memory that connects to five agent patterns which each connect to three shared principles creates a web that is more confusing than helpful. The telescope needs intelligent filtering: show the strongest connections, hide the noise.
  </p>
</ResearchLayout>

<style>
  .telescope-container {
    box-shadow:
      inset 0 1px 0 rgba(201, 169, 97, 0.05),
      0 4px 24px rgba(0, 0, 0, 0.5);
  }

  .zoom-range {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: linear-gradient(to right,
      rgba(201, 169, 97, 0.3),
      rgba(96, 165, 250, 0.3),
      rgba(52, 211, 153, 0.3)
    );
    outline: none;
    position: relative;
    z-index: 2;
    cursor: pointer;
  }

  .zoom-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #c9a961;
    border: 2px solid #0a0a0a;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(201, 169, 97, 0.4);
    transition: box-shadow 0.2s;
  }

  .zoom-range::-webkit-slider-thumb:hover {
    box-shadow: 0 0 16px rgba(201, 169, 97, 0.6);
  }

  .zoom-range::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #c9a961;
    border: 2px solid #0a0a0a;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(201, 169, 97, 0.4);
  }

  .slider-track {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    transform: translateY(-50%);
    height: 6px;
    pointer-events: none;
  }

  .slider-tick {
    position: absolute;
    top: -3px;
    width: 2px;
    height: 12px;
    background: rgba(184, 184, 184, 0.15);
    transform: translateX(-50%);
  }

  .scope-label {
    min-width: 50px;
    transition: color 0.3s;
  }

  .telescope-viewport {
    position: relative;
    padding: 20px;
    min-height: 480px;
  }

  .connection-lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  .views-container {
    position: relative;
    z-index: 2;
  }

  .scope-view {
    transition: opacity 0.4s ease, transform 0.4s ease;
    margin-bottom: 8px;
  }

  .scope-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    padding: 0 4px;
  }

  .scope-tag {
    font-family: var(--font-family-mono);
    font-size: 10px;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 2px;
    letter-spacing: 0.03em;
  }

  .scope-tag.session {
    background: rgba(201, 169, 97, 0.1);
    color: #c9a961;
    border: 1px solid rgba(201, 169, 97, 0.2);
  }

  .scope-tag.agent {
    background: rgba(96, 165, 250, 0.1);
    color: #60a5fa;
    border: 1px solid rgba(96, 165, 250, 0.2);
  }

  .scope-tag.shared {
    background: rgba(52, 211, 153, 0.1);
    color: #34d399;
    border: 1px solid rgba(52, 211, 153, 0.2);
  }

  .scope-desc {
    font-family: var(--font-family-serif);
    font-size: 11px;
    color: rgba(184, 184, 184, 0.3);
    font-style: italic;
  }

  .memory-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .memory-item {
    padding: 10px 14px;
    border-radius: 2px;
    transition: all 0.3s;
  }

  .session-item {
    background: rgba(201, 169, 97, 0.04);
    border: 1px solid rgba(201, 169, 97, 0.08);
    border-left: 3px solid rgba(201, 169, 97, 0.2);
  }

  .agent-item {
    background: rgba(96, 165, 250, 0.04);
    border: 1px solid rgba(96, 165, 250, 0.08);
    border-left: 3px solid rgba(96, 165, 250, 0.2);
  }

  .shared-item {
    background: rgba(52, 211, 153, 0.04);
    border: 1px solid rgba(52, 211, 153, 0.08);
    border-left: 3px solid rgba(52, 211, 153, 0.2);
  }

  .memory-text {
    display: block;
    font-family: var(--font-family-serif);
    font-size: 13px;
    color: #e8e8e8;
    line-height: 1.5;
    margin-bottom: 4px;
  }

  .memory-meta {
    display: block;
    font-family: var(--font-family-mono);
    font-size: 9px;
    color: rgba(184, 184, 184, 0.3);
  }

  .transform-annotation {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 0;
    opacity: 0.3;
    transition: opacity 0.4s;
  }

  .annotation-line {
    flex: 1;
    height: 1px;
    background: linear-gradient(to right, transparent, rgba(201, 169, 97, 0.15), transparent);
  }

  .annotation-text {
    font-family: var(--font-family-mono);
    font-size: 9px;
    color: rgba(201, 169, 97, 0.3);
    white-space: nowrap;
    letter-spacing: 0.03em;
  }
</style>

<script>
  const slider = document.getElementById('zoom-slider') as HTMLInputElement;
  const viewSession = document.getElementById('view-session');
  const viewAgent = document.getElementById('view-agent');
  const viewShared = document.getElementById('view-shared');
  const annotation1 = document.getElementById('annotation-1');
  const annotation2 = document.getElementById('annotation-2');
  const scopeLabel = document.getElementById('current-scope-label');
  const sessionLabel = document.querySelector('.session-label') as HTMLElement;
  const sharedLabel = document.querySelector('.shared-label') as HTMLElement;
  const svg = document.getElementById('connection-svg');

  function lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
  }

  function clamp(v: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, v));
  }

  function updateView(value: number) {
    const t = value / 100;

    // Compute opacities for each scope
    // Session: fully visible at 0, fades out by 0.5
    const sessionOpacity = clamp(1 - t * 2.5, 0.12, 1);
    // Agent: fades in around 0.3, fully visible at 0.5, fades slightly at 1
    const agentOpacity = t < 0.3 ? clamp(lerp(0.2, 0.6, t / 0.3), 0.12, 1) : t < 0.7 ? 1 : clamp(lerp(1, 0.4, (t - 0.7) / 0.3), 0.12, 1);
    // Shared: fades in around 0.5, fully visible at 1
    const sharedOpacity = clamp(lerp(0.12, 1, (t - 0.4) / 0.6), 0.12, 1);

    if (viewSession) viewSession.style.opacity = String(sessionOpacity);
    if (viewAgent) viewAgent.style.opacity = String(agentOpacity);
    if (viewShared) viewShared.style.opacity = String(sharedOpacity);

    // Annotation visibility
    if (annotation1) annotation1.style.opacity = String(clamp(t < 0.5 ? t * 3 : 1 - (t - 0.5) * 2, 0.1, 0.8));
    if (annotation2) annotation2.style.opacity = String(clamp((t - 0.4) * 3, 0.1, 0.8));

    // Update label
    if (scopeLabel) {
      if (t < 0.33) scopeLabel.textContent = 'session:run-2024-02-18';
      else if (t < 0.66) scopeLabel.textContent = 'agent:deploy-bot';
      else scopeLabel.textContent = 'shared';
    }

    // Update scope label colors
    if (sessionLabel) {
      sessionLabel.style.color = t < 0.33 ? '#c9a961' : 'rgba(184,184,184,0.3)';
    }
    if (sharedLabel) {
      sharedLabel.style.color = t > 0.66 ? '#34d399' : 'rgba(184,184,184,0.3)';
    }

    // Draw connection lines
    drawConnections(t);
  }

  function drawConnections(t: number) {
    if (!svg) return;

    const groups = [1, 2, 3];
    let paths = '';

    groups.forEach(group => {
      const sessionItems = document.querySelectorAll(`.session-item[data-group="${group}"]`);
      const agentItems = document.querySelectorAll(`.agent-item[data-group="${group}"]`);
      const sharedItems = document.querySelectorAll(`.shared-item[data-group="${group}"]`);

      if (sessionItems.length === 0 || agentItems.length === 0 || sharedItems.length === 0) return;

      const viewport = document.getElementById('telescope-viewport');
      if (!viewport) return;
      const vRect = viewport.getBoundingClientRect();

      const getCenter = (el: Element) => {
        const r = el.getBoundingClientRect();
        return {
          x: ((r.left + r.width / 2 - vRect.left) / vRect.width) * 800,
          y: ((r.top + r.height / 2 - vRect.top) / vRect.height) * 500
        };
      };

      const s = getCenter(sessionItems[0]);
      const a = getCenter(agentItems[0]);
      const sh = getCenter(sharedItems[0]);

      // Session to Agent connection
      const saOpacity = clamp(t < 0.5 ? t * 3 : 1.5 - t, 0, 0.5);
      if (saOpacity > 0.01) {
        paths += `<line x1="${s.x}" y1="${s.y}" x2="${a.x}" y2="${a.y}" stroke="rgba(201,169,97,${saOpacity})" stroke-width="1" stroke-dasharray="4 4"/>`;
      }

      // Agent to Shared connection
      const asOpacity = clamp((t - 0.3) * 2, 0, 0.5);
      if (asOpacity > 0.01) {
        paths += `<line x1="${a.x}" y1="${a.y}" x2="${sh.x}" y2="${sh.y}" stroke="rgba(52,211,153,${asOpacity})" stroke-width="1" stroke-dasharray="4 4"/>`;
      }
    });

    svg.innerHTML = paths;
  }

  slider?.addEventListener('input', () => {
    updateView(parseInt(slider.value));
  });

  // Initialize
  updateView(0);

  // Redraw connections on resize
  window.addEventListener('resize', () => {
    updateView(parseInt(slider?.value || '0'));
  });
</script>
