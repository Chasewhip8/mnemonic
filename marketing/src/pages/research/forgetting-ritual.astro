---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('forgetting-ritual')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="demo-forgetting-wrapper bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Header -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10">
        <div class="flex items-center gap-3">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/60">Weekly Review</span>
          <span id="review-progress" class="font-mono text-[10px] text-chrome-dark/40">1 of 5</span>
        </div>
        <div id="review-summary" class="flex items-center gap-4">
          <span class="font-mono text-[10px] text-[#8bba7f]">Confirmed: <span id="count-confirmed">0</span></span>
          <span class="font-mono text-[10px] text-red-400/70">Released: <span id="count-released">0</span></span>
          <span class="font-mono text-[10px] text-[#c9a961]">Rephrased: <span id="count-rephrased">0</span></span>
        </div>
      </div>

      <!-- Card stack area -->
      <div id="card-area" class="relative flex items-center justify-center px-6 py-10 min-h-[340px] overflow-hidden">
        <!-- Cards rendered by JS -->

        <!-- Completion screen -->
        <div id="completion-screen" class="hidden text-center py-8">
          <div class="font-serif-sc text-xl font-bold text-brass mb-3">Review complete</div>
          <p id="completion-message" class="font-serif text-sm text-chrome-dark/60 mb-6 max-w-sm mx-auto"></p>
          <button id="restart-btn" class="font-mono text-[10px] px-4 py-2 rounded-sm border border-brass/20 text-brass/70 hover:text-brass hover:border-brass/40 transition-colors">
            Review again
          </button>
        </div>
      </div>

      <!-- Action buttons -->
      <div id="action-buttons" class="px-5 py-4 border-t border-brass/10 flex items-center justify-center gap-6">
        <button id="btn-release" class="action-btn group flex flex-col items-center gap-1.5">
          <div class="w-12 h-12 rounded-full border-2 border-red-400/30 flex items-center justify-center group-hover:border-red-400/60 group-hover:bg-red-400/5 transition-all">
            <svg class="w-5 h-5 text-red-400/50 group-hover:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </div>
          <span class="font-mono text-[9px] text-red-400/40 group-hover:text-red-400/70 transition-colors">Release</span>
        </button>
        <button id="btn-rephrase" class="action-btn group flex flex-col items-center gap-1.5">
          <div class="w-10 h-10 rounded-full border-2 border-brass/30 flex items-center justify-center group-hover:border-brass/60 group-hover:bg-brass/5 transition-all">
            <svg class="w-4 h-4 text-brass/50 group-hover:text-brass" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 15l7-7 7 7"/>
            </svg>
          </div>
          <span class="font-mono text-[9px] text-brass/40 group-hover:text-brass/70 transition-colors">Rephrase</span>
        </button>
        <button id="btn-confirm" class="action-btn group flex flex-col items-center gap-1.5">
          <div class="w-12 h-12 rounded-full border-2 border-[#8bba7f]/30 flex items-center justify-center group-hover:border-[#8bba7f]/60 group-hover:bg-[#8bba7f]/5 transition-all">
            <svg class="w-5 h-5 text-[#8bba7f]/50 group-hover:text-[#8bba7f]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 13l4 4L19 7"/>
            </svg>
          </div>
          <span class="font-mono text-[9px] text-[#8bba7f]/40 group-hover:text-[#8bba7f]/70 transition-colors">Confirm</span>
        </button>
      </div>

      <!-- Footer -->
      <div class="px-5 py-2.5 border-t border-brass/10">
        <span class="font-mono text-[10px] text-chrome-dark/30">Drag the card or use the buttons below. Release to forget, rephrase to edit, confirm to keep.</span>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#philosophical-note" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Philosophical note</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>
  <p>
    Once a week, a prompt arrives. Not urgent, not demanding. Something closer to a suggestion: "You have 8 memories ready for review." You open the interface and find a stack of cards. Each one represents a learning your agent has stored -- something it picked up during a run, a pattern it noticed, a preference you expressed. The cards are sorted by confidence, lowest first, so you start with the memories most likely to need your attention.
  </p>
  <p>
    The top card shows everything: the trigger that surfaces the memory, the learning itself, the confidence score (low, colored accordingly), the scope (session, agent, or shared), how old it is, and how many times it has been recalled. You read it. You consider it. Then you act.
  </p>
  <p>
    Swipe right to confirm: this memory is accurate, keep it, boost its confidence. Swipe left to release: this memory has served its purpose or was never quite right, let it go. Swipe up to rephrase: the core insight is sound but the wording needs work, the scope needs adjusting, or the confidence needs manual correction. Each gesture animates the card away -- flying off to the right with a gentle rotation, dropping to the left and fading, rising upward with a golden glow.
  </p>
  <p>
    The next card rises to take its place. You work through the stack. A progress indicator ticks upward. A running summary builds: confirmed 3, released 2, rephrased 1. When the last card is reviewed, a summary screen appears. "Your memory is 15% lighter. You confirmed 4, released 3, rephrased 1." The ritual is complete. You close the interface and go about your week, knowing that the memories that remain are the ones you chose to keep.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>
  <p>
    The forgetting ritual reveals something that most memory systems suppress: the value of agency over what you remember. Human memory is healthy precisely because it forgets. We do not retain every fact, every conversation, every sensation. We retain what matters and release what does not. This is not a flaw. It is the mechanism by which memory stays useful. A brain that remembered everything would be paralyzed by irrelevance.
  </p>
  <p>
    Artificial memory systems, by default, do the opposite. They store everything and delete nothing unless forced to by storage limits or automated cleanup. This is the database mentality: data is valuable, deletion is loss, completeness is the goal. But completeness is not the same as usefulness. A memory system with ten thousand entries, half of which are outdated, contradictory, or trivially obvious, is worse than one with five thousand entries that are all current, coherent, and genuinely informative.
  </p>
  <p>
    The forgetting ritual gives this power to the human. It says: you decide what survives. Not the decay algorithm, not the storage limit, not the automated cleanup. You. This is important because the criteria for "worth keeping" are subjective and contextual. An automated system might delete a low-confidence memory that the human knows is critically important -- it just has not been recalled recently because the situation has not arisen. Conversely, a high-confidence memory might be completely outdated because the technology it refers to has changed. Only the human can make these judgments reliably.
  </p>
  <p>
    The card-by-card format matters too. Batch operations -- "select all below 0.3 and delete" -- are efficient but thoughtless. The ritual forces you to look at each memory individually, consider its value, and make a conscious choice. This is slower. That is the point. The slowness is what makes it a practice rather than a chore.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>
  <p>
    Deja already implements automated forgetting. The cleanup cron runs daily, identifies learnings below a confidence threshold, and removes them. This is the machine version of forgetting: efficient, consistent, and undiscriminating. It works well for clearing obvious dead weight -- memories that have decayed to near-zero confidence and have not been recalled in months.
  </p>
  <p>
    The forgetting ritual is the human-in-the-loop complement to this automated process. Instead of deleting memories silently, the system surfaces them for review first. The implementation maps cleanly to deja's existing API. Confirming a memory sends a <code>PATCH /learnings/:id</code> request that bumps confidence by 0.2 and updates <code>last_recalled_at</code>. Releasing a memory sends a <code>DELETE /learnings/:id</code> request. Rephrasing sends a <code>PATCH</code> that updates the <code>learning</code> text, and potentially the <code>trigger</code> or <code>scope</code>.
  </p>
  <p>
    The selection of which memories to surface for review is itself an interesting design problem. The obvious approach is to show memories below a confidence threshold, sorted ascending. But a more nuanced approach might consider several factors: confidence (lower is more likely to need review), age (older memories are more likely to be outdated), recall count (unrealled memories are more likely to be irrelevant), and scope (session-scoped memories are more likely to be ephemeral). A weighted score combining these factors would produce a review queue ordered by "most likely to benefit from human judgment."
  </p>
  <p>
    The weekly cadence is deliberate. Daily would be exhausting. Monthly would let too much accumulate. Weekly creates a rhythm that is sustainable and frequent enough to keep memory healthy. The number of cards per session should also be bounded -- five to ten, not fifty. The ritual should take two to three minutes, not twenty. If there are more memories to review than fit in one session, they carry over to the next week.
  </p>

  <h2 id="design-tensions">Design tensions</h2>
  <p>
    Deja's tagline is "what survives a run." This implies a Darwinian frame: memories compete, the fittest persist, the weak are eliminated. The forgetting ritual complicates this frame by introducing human judgment into the selection process. It asks: should survival be determined by algorithmic fitness or by human intention? And the answer is both, but with different rhythms. The algorithm handles the continuous, automated decay. The human handles the periodic, intentional curation.
  </p>
  <p>
    There is a tension between the efficiency of automation and the quality of human judgment. The cleanup cron can process thousands of memories in milliseconds. The forgetting ritual processes five to ten per week. If the cron is too aggressive, the ritual has nothing left to review. If the cron is too conservative, the ritual becomes overwhelming. The right balance is for the cron to handle clear-cut cases (confidence below 0.1, no recalls, older than 6 months) and for the ritual to handle the ambiguous middle -- memories between 0.2 and 0.5 confidence where the right action is genuinely uncertain.
  </p>
  <p>
    Another tension: the swipe interface is inherently binary in feel, even with the third "rephrase" option. Left or right. Keep or release. This framing can encourage snap judgments. The design needs to resist this by giving enough information on each card to make an informed decision and by making the rephrase option as accessible as the binary choices. A memory worth rephrasing is often more valuable than one worth confirming, because it indicates that the agent's learning was directionally correct but not yet precise.
  </p>
  <p>
    There is also the question of permanence. When you release a memory, is it gone forever? Or can it be recovered? A hard delete is clean but irreversible. A soft delete (moving to a "compost" area for 30 days) is safer but undermines the ritual's meaning. If you can always get a memory back, the release gesture loses its weight. The ritual is specifically designed to feel consequential. You are making a real choice. The tension is between safety and significance.
  </p>

  <h2 id="philosophical-note">Philosophical note</h2>
  <p>
    The best memory systems are opinionated about what is worth keeping. Human memory is famously opinionated: it privileges emotional experiences, repeated patterns, and recent events. It discards the mundane, the contradicted, and the irrelevant. These are not neutral criteria. They reflect a point of view about what matters. And because of this bias, human memory is extraordinarily useful. It does not give you everything. It gives you what you need.
  </p>
  <p>
    Artificial memory systems tend to be unopinionated by design. They store what they are told to store and retrieve what matches a query. This neutrality is a feature in databases. It is a liability in memory systems meant to support intelligent behavior. An agent that remembers everything equally is an agent that knows nothing well. It will retrieve ten memories when one would suffice, and it will weight a stale observation from six months ago the same as a hard-won lesson from yesterday.
  </p>
  <p>
    The forgetting ritual is an argument for opinionated memory. Not opinionated by algorithm alone, but opinionated by human choice. Each swipe is a statement about value: this matters, this does not, this needs refinement. Over time, the memory that remains is not a comprehensive record. It is a curated body of knowledge shaped by judgment. And that curated body will be more useful, more coherent, and more trustworthy than any complete record could be.
  </p>
  <p>
    There is something almost meditative about the practice. One card at a time. No rush. Consider, decide, move on. It is the opposite of the productivity mindset that pervades most software. It asks you to slow down, to look at what you know, and to decide what deserves to continue. This is not efficiency. It is care. And in a memory system, care is what separates a pile of data from a body of knowledge.
  </p>
</ResearchLayout>

<style>
  .memory-card {
    position: absolute;
    width: 320px;
    max-width: 90%;
    border-radius: 4px;
    cursor: grab;
    user-select: none;
    touch-action: none;
    transition: box-shadow 0.2s ease;
  }

  .memory-card:active {
    cursor: grabbing;
  }

  .memory-card.dragging {
    transition: none;
    z-index: 100 !important;
  }

  .memory-card .card-inner {
    padding: 1.25rem;
    position: relative;
  }

  .card-confidence-bar {
    height: 2px;
    border-radius: 1px;
    overflow: hidden;
  }

  .card-confidence-fill {
    height: 100%;
    border-radius: 1px;
    transition: width 0.3s ease;
  }

  .memory-card.fly-right {
    animation: card-fly-right 0.45s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .memory-card.fly-left {
    animation: card-fly-left 0.45s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .memory-card.fly-up {
    animation: card-fly-up 0.45s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes card-fly-right {
    to {
      transform: translateX(150%) rotate(15deg);
      opacity: 0;
    }
  }

  @keyframes card-fly-left {
    to {
      transform: translateX(-150%) rotate(-15deg);
      opacity: 0;
    }
  }

  @keyframes card-fly-up {
    to {
      transform: translateY(-150%) rotate(5deg);
      opacity: 0;
    }
  }

  .memory-card.rising {
    animation: card-rise 0.35s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes card-rise {
    from {
      transform: scale(0.95) translateY(8px);
      opacity: 0.7;
    }
    to {
      transform: scale(1) translateY(0);
      opacity: 1;
    }
  }

  .action-indicator {
    position: absolute;
    top: 1rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: bold;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 2px 8px;
    border-radius: 2px;
    opacity: 0;
    transition: opacity 0.15s ease;
    pointer-events: none;
  }

  .action-indicator.release-indicator {
    left: 1rem;
    color: #f87171;
    border: 1px solid rgba(248, 113, 113, 0.3);
    background: rgba(248, 113, 113, 0.05);
  }

  .action-indicator.confirm-indicator {
    right: 1rem;
    color: #8bba7f;
    border: 1px solid rgba(139, 186, 127, 0.3);
    background: rgba(139, 186, 127, 0.05);
  }

  .action-indicator.rephrase-indicator {
    left: 50%;
    transform: translateX(-50%);
    top: 0.5rem;
    color: #c9a961;
    border: 1px solid rgba(201, 169, 97, 0.3);
    background: rgba(201, 169, 97, 0.05);
  }
</style>

<script>
  interface MemoryCard {
    id: number;
    trigger: string;
    learning: string;
    confidence: number;
    scope: string;
    age: string;
    recallCount: number;
  }

  const initialCards: MemoryCard[] = [
    {
      id: 1,
      trigger: 'websocket auth',
      learning: 'Authenticate WebSocket connections on the initial handshake, not on the first message, to prevent unauthenticated frames from reaching the handler.',
      confidence: 0.28,
      scope: 'session',
      age: '4 months ago',
      recallCount: 0,
    },
    {
      id: 2,
      trigger: 'docker layer cache',
      learning: 'Order Dockerfile commands from least to most frequently changed to maximize layer caching. COPY package.json before COPY . to avoid reinstalling dependencies on every code change.',
      confidence: 0.42,
      scope: 'agent',
      age: '2 months ago',
      recallCount: 1,
    },
    {
      id: 3,
      trigger: 'rate limiting',
      learning: 'Apply rate limiting at the API gateway level for consistent enforcement across services. Application-level rate limiting creates inconsistencies when services scale independently.',
      confidence: 0.55,
      scope: 'shared',
      age: '6 weeks ago',
      recallCount: 2,
    },
    {
      id: 4,
      trigger: 'migration order',
      learning: 'Always run database migrations before deploying new application code. Deploying first creates a window where the app expects a schema the database does not yet have.',
      confidence: 0.72,
      scope: 'agent',
      age: '3 weeks ago',
      recallCount: 4,
    },
    {
      id: 5,
      trigger: 'error boundaries',
      learning: 'Wrap every async route handler in an error boundary. Unhandled promise rejections in Express crash the process silently, and the container restarts without logging the cause.',
      confidence: 0.85,
      scope: 'shared',
      age: '1 week ago',
      recallCount: 7,
    },
  ];

  let cards = [...initialCards];
  let currentIndex = 0;
  let results: { id: number; action: string }[] = [];

  // Drag state
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let currentCardEl: HTMLElement | null = null;

  function getConfidenceColor(conf: number): string {
    if (conf >= 0.7) return '#c9a961';
    if (conf >= 0.4) return '#8b7a50';
    return '#666';
  }

  function getCardBorderColor(conf: number): string {
    if (conf >= 0.7) return 'rgba(201, 169, 97, 0.25)';
    if (conf >= 0.4) return 'rgba(201, 169, 97, 0.12)';
    return 'rgba(100, 100, 100, 0.2)';
  }

  function getCardBg(conf: number): string {
    if (conf >= 0.7) return 'rgba(201, 169, 97, 0.03)';
    if (conf >= 0.4) return 'rgba(26, 26, 26, 0.8)';
    return 'rgba(26, 26, 26, 0.6)';
  }

  function renderCards() {
    const area = document.getElementById('card-area')!;
    const completion = document.getElementById('completion-screen')!;
    const actionBtns = document.getElementById('action-buttons')!;

    // Clear old cards
    area.querySelectorAll('.memory-card').forEach(el => el.remove());

    if (currentIndex >= cards.length) {
      completion.classList.remove('hidden');
      actionBtns.style.opacity = '0.3';
      actionBtns.style.pointerEvents = 'none';
      showCompletion();
      return;
    }

    completion.classList.add('hidden');
    actionBtns.style.opacity = '1';
    actionBtns.style.pointerEvents = 'auto';

    // Render remaining cards (back to front)
    const remaining = cards.length - currentIndex;
    const visibleCount = Math.min(remaining, 3);

    for (let i = visibleCount - 1; i >= 0; i--) {
      const card = cards[currentIndex + i];
      const el = createCardElement(card, i);
      area.appendChild(el);
    }

    updateProgress();
  }

  function createCardElement(card: MemoryCard, stackIndex: number): HTMLElement {
    const el = document.createElement('div');
    el.className = 'memory-card';
    el.dataset.id = String(card.id);

    const scale = 1 - stackIndex * 0.04;
    const yOffset = stackIndex * 8;
    const confColor = getConfidenceColor(card.confidence);
    const borderColor = getCardBorderColor(card.confidence);
    const bgColor = getCardBg(card.confidence);

    el.style.cssText = `
      background: ${bgColor};
      border: 1px solid ${borderColor};
      z-index: ${10 - stackIndex};
      transform: scale(${scale}) translateY(${yOffset}px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.4), inset 0 1px 0 rgba(201,169,97,0.05);
    `;

    if (stackIndex > 0) {
      el.style.pointerEvents = 'none';
    }

    el.innerHTML = `
      <div class="action-indicator release-indicator">Release</div>
      <div class="action-indicator confirm-indicator">Confirm</div>
      <div class="action-indicator rephrase-indicator">Rephrase</div>
      <div class="card-inner">
        <div class="flex items-center justify-between mb-3">
          <span class="font-mono text-[11px] font-bold text-chrome">${card.trigger}</span>
          <span class="font-mono text-[9px] text-chrome-dark/30">${card.age}</span>
        </div>
        <p class="font-serif text-[13px] text-chrome-dark leading-relaxed m-0 mb-4">${card.learning}</p>
        <div class="card-confidence-bar bg-steel-light/30 mb-3">
          <div class="card-confidence-fill" style="width: ${card.confidence * 100}%; background: ${confColor};"></div>
        </div>
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <span class="font-mono text-[9px]" style="color: ${confColor};">confidence: ${card.confidence.toFixed(2)}</span>
            <span class="font-mono text-[9px] text-chrome-dark/30">recalled ${card.recallCount}x</span>
          </div>
          <span class="font-mono text-[9px] text-chrome-dark/30 px-1.5 py-0.5 border border-chrome-dark/10 rounded-sm">${card.scope}</span>
        </div>
      </div>
    `;

    if (stackIndex === 0) {
      el.classList.add('rising');
      setupDrag(el);
    }

    return el;
  }

  function setupDrag(el: HTMLElement) {
    const onStart = (clientX: number, clientY: number) => {
      isDragging = true;
      dragStartX = clientX;
      dragStartY = clientY;
      dragOffsetX = 0;
      dragOffsetY = 0;
      currentCardEl = el;
      el.classList.add('dragging');
      el.style.transition = 'none';
    };

    const onMove = (clientX: number, clientY: number) => {
      if (!isDragging || !currentCardEl) return;
      dragOffsetX = clientX - dragStartX;
      dragOffsetY = clientY - dragStartY;
      const rotation = dragOffsetX * 0.05;
      currentCardEl.style.transform = `translate(${dragOffsetX}px, ${dragOffsetY}px) rotate(${rotation}deg)`;

      // Show action indicators
      const releaseInd = currentCardEl.querySelector('.release-indicator') as HTMLElement;
      const confirmInd = currentCardEl.querySelector('.confirm-indicator') as HTMLElement;
      const rephraseInd = currentCardEl.querySelector('.rephrase-indicator') as HTMLElement;

      const threshold = 60;
      releaseInd.style.opacity = dragOffsetX < -threshold ? '1' : '0';
      confirmInd.style.opacity = dragOffsetX > threshold ? '1' : '0';
      rephraseInd.style.opacity = dragOffsetY < -threshold && Math.abs(dragOffsetX) < threshold ? '1' : '0';
    };

    const onEnd = () => {
      if (!isDragging || !currentCardEl) return;
      isDragging = false;
      currentCardEl.classList.remove('dragging');

      const threshold = 80;
      if (dragOffsetX > threshold) {
        performAction('confirm');
      } else if (dragOffsetX < -threshold) {
        performAction('release');
      } else if (dragOffsetY < -threshold && Math.abs(dragOffsetX) < threshold) {
        performAction('rephrase');
      } else {
        // Snap back
        currentCardEl.style.transition = 'transform 0.3s cubic-bezier(0.16, 1, 0.3, 1)';
        currentCardEl.style.transform = 'scale(1) translateY(0)';
        const indicators = currentCardEl.querySelectorAll('.action-indicator') as NodeListOf<HTMLElement>;
        indicators.forEach(ind => ind.style.opacity = '0');
      }
      currentCardEl = null;
    };

    // Mouse events
    el.addEventListener('mousedown', (e: MouseEvent) => {
      e.preventDefault();
      onStart(e.clientX, e.clientY);
    });
    document.addEventListener('mousemove', (e: MouseEvent) => onMove(e.clientX, e.clientY));
    document.addEventListener('mouseup', () => onEnd());

    // Touch events
    el.addEventListener('touchstart', (e: TouchEvent) => {
      const touch = e.touches[0];
      onStart(touch.clientX, touch.clientY);
    }, { passive: true });
    document.addEventListener('touchmove', (e: TouchEvent) => {
      const touch = e.touches[0];
      onMove(touch.clientX, touch.clientY);
    }, { passive: true });
    document.addEventListener('touchend', () => onEnd());
  }

  function performAction(action: 'confirm' | 'release' | 'rephrase') {
    const area = document.getElementById('card-area')!;
    const topCard = area.querySelector('.memory-card:not([style*="pointer-events: none"])') as HTMLElement;
    if (!topCard) return;

    results.push({ id: cards[currentIndex].id, action });

    // Animate the card away
    const flyClass = action === 'confirm' ? 'fly-right' : action === 'release' ? 'fly-left' : 'fly-up';
    topCard.style.transition = '';
    topCard.classList.add(flyClass);

    // Update counts
    updateCounts();

    topCard.addEventListener('animationend', () => {
      currentIndex++;
      renderCards();
    }, { once: true });
  }

  function updateProgress() {
    const progress = document.getElementById('review-progress')!;
    progress.textContent = `${Math.min(currentIndex + 1, cards.length)} of ${cards.length}`;
  }

  function updateCounts() {
    const confirmed = results.filter(r => r.action === 'confirm').length;
    const released = results.filter(r => r.action === 'release').length;
    const rephrased = results.filter(r => r.action === 'rephrase').length;

    document.getElementById('count-confirmed')!.textContent = String(confirmed);
    document.getElementById('count-released')!.textContent = String(released);
    document.getElementById('count-rephrased')!.textContent = String(rephrased);
  }

  function showCompletion() {
    const confirmed = results.filter(r => r.action === 'confirm').length;
    const released = results.filter(r => r.action === 'release').length;
    const rephrased = results.filter(r => r.action === 'rephrase').length;
    const pct = Math.round((released / cards.length) * 100);

    const msg = document.getElementById('completion-message')!;
    msg.textContent = `Your memory is ${pct}% lighter. You confirmed ${confirmed}, released ${released}, and rephrased ${rephrased}. ${released > 0 ? 'The released memories will be composted.' : 'Nothing was released this session.'}`;
  }

  // Button handlers
  document.getElementById('btn-confirm')?.addEventListener('click', () => {
    if (currentIndex < cards.length) performAction('confirm');
  });
  document.getElementById('btn-release')?.addEventListener('click', () => {
    if (currentIndex < cards.length) performAction('release');
  });
  document.getElementById('btn-rephrase')?.addEventListener('click', () => {
    if (currentIndex < cards.length) performAction('rephrase');
  });

  // Restart
  document.getElementById('restart-btn')?.addEventListener('click', () => {
    currentIndex = 0;
    results = [];
    updateCounts();
    renderCards();
  });

  // Initial render
  renderCards();
</script>
