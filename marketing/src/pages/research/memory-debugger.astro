---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('memory-debugger')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="debugger-demo bg-void-deep border border-brass/15 rounded-sm overflow-hidden" id="memory-debugger">
      <!-- Debugger Header -->
      <div class="px-6 py-4 border-b border-brass/10 flex items-center justify-between flex-wrap gap-3">
        <div>
          <div class="font-mono text-[10px] tracking-widest uppercase text-chrome-dark/40 mb-1">Memory Trace</div>
          <h3 class="font-serif text-lg font-semibold m-0 text-chrome">Run <span class="text-brass">#1847</span> <span class="text-chrome-dark/40 font-mono text-[12px]">-- deploy-bot</span></h3>
        </div>
        <div class="font-mono text-[11px] text-chrome-dark/50">
          Total duration: <span class="text-chrome">342ms</span>
        </div>
      </div>

      <!-- Threshold Slider -->
      <div class="px-6 py-3 border-b border-brass/10 bg-steel/20">
        <div class="flex items-center gap-4">
          <label class="font-mono text-[10px] tracking-widest uppercase text-chrome-dark/40 whitespace-nowrap">What if? Threshold:</label>
          <input type="range" id="threshold-slider" min="0" max="100" value="65" class="threshold-range flex-1 max-w-xs" />
          <span id="threshold-value" class="font-mono text-[12px] text-brass font-bold min-w-[3ch]">0.65</span>
          <span id="threshold-result" class="font-mono text-[10px] text-chrome-dark/50">3 memories pass</span>
        </div>
      </div>

      <!-- Waterfall Steps -->
      <div class="p-6" id="waterfall-container">
        <!-- Step 1: Context Received -->
        <div class="waterfall-step" data-step="1" data-delay="0">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-brass border-2 border-brass/50 flex-shrink-0"></div>
              <div class="step-line flex-1 w-px bg-brass/20 mt-1"></div>
            </div>
            <div class="flex-1 pb-6">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-brass">01</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Context received</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">0ms</span>
                </div>
                <span class="step-expand font-mono text-[10px] text-chrome-dark/30">+</span>
              </div>
              <div class="step-preview mt-2">
                <div class="font-mono text-[11px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/70 truncate">
                  "about to deploy auth service to production"
                </div>
              </div>
              <div class="step-detail hidden mt-2">
                <div class="font-mono text-[11px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/70 space-y-1">
                  <div><span class="text-brass/60">input:</span> "about to deploy auth service to production"</div>
                  <div><span class="text-brass/60">agent:</span> deploy-bot</div>
                  <div><span class="text-brass/60">scope:</span> agent:deploy-bot, shared:infrastructure</div>
                  <div><span class="text-brass/60">run_id:</span> run_1847_a3f8c</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 2: Embedding Generated -->
        <div class="waterfall-step" data-step="2" data-delay="200">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-brass border-2 border-brass/50 flex-shrink-0"></div>
              <div class="step-line flex-1 w-px bg-brass/20 mt-1"></div>
            </div>
            <div class="flex-1 pb-6">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-brass">02</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Embedding generated</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">12ms</span>
                </div>
                <span class="step-expand font-mono text-[10px] text-chrome-dark/30">+</span>
              </div>
              <div class="step-preview mt-2">
                <div class="embedding-bars flex items-end gap-0.5 h-6 px-3">
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 85%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 42%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 67%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 91%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 23%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 55%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 78%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 34%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 60%"></div>
                  <div class="bg-brass/60 rounded-t-sm" style="width: 6px; height: 48%"></div>
                  <span class="font-mono text-[9px] text-chrome-dark/30 ml-2 self-center">1536 dims</span>
                </div>
              </div>
              <div class="step-detail hidden mt-2">
                <div class="font-mono text-[11px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/70 space-y-1">
                  <div><span class="text-brass/60">model:</span> text-embedding-3-small</div>
                  <div><span class="text-brass/60">dimensions:</span> 1536</div>
                  <div><span class="text-brass/60">latency:</span> 12ms</div>
                  <div><span class="text-brass/60">vector:</span> [0.823, 0.412, 0.667, 0.914, 0.231, ...]</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 3: Memory Search -->
        <div class="waterfall-step" data-step="3" data-delay="400">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-brass border-2 border-brass/50 flex-shrink-0"></div>
              <div class="step-line flex-1 w-px bg-brass/20 mt-1"></div>
            </div>
            <div class="flex-1 pb-6">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-brass">03</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Memory search</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">89ms</span>
                </div>
                <span class="step-expand font-mono text-[10px] text-chrome-dark/30">+</span>
              </div>
              <div class="step-preview mt-2 space-y-1" id="memory-candidates">
                <div class="memory-candidate flex items-center gap-3 px-3 py-1.5 rounded-sm" data-score="92">
                  <div class="score-bar w-16 h-1 bg-void rounded-full overflow-hidden flex-shrink-0">
                    <div class="h-full bg-emerald-500/80 rounded-full" style="width: 92%"></div>
                  </div>
                  <span class="font-mono text-[10px] text-emerald-400 flex-shrink-0 w-8">0.92</span>
                  <span class="font-serif text-[12px] text-chrome/80 truncate">"always run dry-run before deploying"</span>
                </div>
                <div class="memory-candidate flex items-center gap-3 px-3 py-1.5 rounded-sm" data-score="87">
                  <div class="score-bar w-16 h-1 bg-void rounded-full overflow-hidden flex-shrink-0">
                    <div class="h-full bg-emerald-500/80 rounded-full" style="width: 87%"></div>
                  </div>
                  <span class="font-mono text-[10px] text-emerald-400 flex-shrink-0 w-8">0.87</span>
                  <span class="font-serif text-[12px] text-chrome/80 truncate">"check migration state first"</span>
                </div>
                <div class="memory-candidate flex items-center gap-3 px-3 py-1.5 rounded-sm" data-score="71">
                  <div class="score-bar w-16 h-1 bg-void rounded-full overflow-hidden flex-shrink-0">
                    <div class="h-full bg-amber-400/70 rounded-full" style="width: 71%"></div>
                  </div>
                  <span class="font-mono text-[10px] text-amber-400 flex-shrink-0 w-8">0.71</span>
                  <span class="font-serif text-[12px] text-chrome/60 truncate">"use feature flags for risky changes"</span>
                </div>
                <div class="memory-candidate flex items-center gap-3 px-3 py-1.5 rounded-sm" data-score="45">
                  <div class="score-bar w-16 h-1 bg-void rounded-full overflow-hidden flex-shrink-0">
                    <div class="h-full bg-chrome-dark/30 rounded-full" style="width: 45%"></div>
                  </div>
                  <span class="font-mono text-[10px] text-chrome-dark/30 flex-shrink-0 w-8">0.45</span>
                  <span class="font-serif text-[12px] text-chrome-dark/30 truncate">"monitoring dashboards need updating"</span>
                </div>
                <div class="memory-candidate flex items-center gap-3 px-3 py-1.5 rounded-sm" data-score="12">
                  <div class="score-bar w-16 h-1 bg-void rounded-full overflow-hidden flex-shrink-0">
                    <div class="h-full bg-chrome-dark/20 rounded-full" style="width: 12%"></div>
                  </div>
                  <span class="font-mono text-[10px] text-chrome-dark/20 flex-shrink-0 w-8">0.12</span>
                  <span class="font-serif text-[12px] text-chrome-dark/20 truncate">"team standup at 10am"</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 4: Threshold Applied -->
        <div class="waterfall-step" data-step="4" data-delay="600">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-brass border-2 border-brass/50 flex-shrink-0"></div>
              <div class="step-line flex-1 w-px bg-brass/20 mt-1"></div>
            </div>
            <div class="flex-1 pb-6">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-brass">04</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Threshold applied</span>
                  <span id="threshold-label" class="font-mono text-[10px] px-2 py-0.5 rounded-full bg-brass/10 text-brass border border-brass/20">0.65</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">1ms</span>
                </div>
                <span id="pass-count" class="font-mono text-[10px] text-emerald-400">3 passed, 2 filtered</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 5: Injected into Context -->
        <div class="waterfall-step" data-step="5" data-delay="800">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-brass border-2 border-brass/50 flex-shrink-0"></div>
              <div class="step-line flex-1 w-px bg-brass/20 mt-1"></div>
            </div>
            <div class="flex-1 pb-6">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-brass">05</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Injected into context</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">3ms</span>
                </div>
                <span class="step-expand font-mono text-[10px] text-chrome-dark/30">+</span>
              </div>
              <div class="step-preview mt-2">
                <div class="font-mono text-[11px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/50">
                  <span class="text-brass/50">[system]</span> Relevant context from memory: 3 learnings injected
                </div>
              </div>
              <div class="step-detail hidden mt-2">
                <div class="font-mono text-[10px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/60 space-y-1 leading-relaxed">
                  <div class="text-brass/40 mb-2">-- injected prompt fragment --</div>
                  <div>Based on previous experience, remember:</div>
                  <div class="pl-3 border-l border-brass/20 mt-1 mb-1 space-y-1">
                    <div>- Always run dry-run before deploying (confidence: 0.95)</div>
                    <div>- Check migration state first (confidence: 0.87)</div>
                    <div>- Use feature flags for risky changes (confidence: 0.71)</div>
                  </div>
                  <div class="text-brass/40">-- end fragment --</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 6: Run Completed -->
        <div class="waterfall-step" data-step="6" data-delay="1000">
          <div class="flex items-stretch gap-4">
            <div class="step-timeline flex flex-col items-center">
              <div class="step-dot w-3 h-3 rounded-full bg-emerald-500 border-2 border-emerald-500/50 flex-shrink-0"></div>
            </div>
            <div class="flex-1 pb-2">
              <div class="step-header cursor-pointer flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="font-mono text-[11px] font-bold text-emerald-400">06</span>
                  <span class="font-serif font-semibold text-chrome text-sm">Run completed</span>
                  <span class="font-mono text-[10px] text-chrome-dark/30">342ms total</span>
                </div>
                <span class="step-expand font-mono text-[10px] text-chrome-dark/30">+</span>
              </div>
              <div class="step-preview mt-2">
                <div class="flex gap-3 font-mono text-[11px]">
                  <span class="px-2 py-0.5 rounded-sm bg-emerald-500/10 text-emerald-400 border border-emerald-500/20">+2 new learnings</span>
                  <span class="px-2 py-0.5 rounded-sm bg-amber-400/10 text-amber-400 border border-amber-400/20">1 confidence boosted</span>
                </div>
              </div>
              <div class="step-detail hidden mt-2">
                <div class="font-mono text-[10px] bg-void px-3 py-2 rounded-sm border border-brass/10 text-chrome-dark/60 space-y-2">
                  <div><span class="text-emerald-400">NEW:</span> "always verify SSL certs after deploy" (confidence: 0.60)</div>
                  <div><span class="text-emerald-400">NEW:</span> "canary deploys reduce risk" (confidence: 0.55)</div>
                  <div><span class="text-amber-400">BOOSTED:</span> "always run dry-run before deploying" 0.92 -> 0.95</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Demo footer -->
      <div class="px-6 py-3 border-t border-brass/10 bg-steel/20">
        <div class="font-mono text-[10px] text-chrome-dark/30 text-center">Interactive demo -- click steps to expand, drag threshold slider to see what changes</div>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#why-essential" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Why essential</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>
  <p>
    You select a run from the history. Maybe it is the one that went wrong -- the deploy that skipped the dry-run, the migration that ran out of order. Or maybe you are just curious: what did the agent know when it made that decision?
  </p>
  <p>
    The debugger opens as a waterfall. Each step in the memory lifecycle is a row in a vertical sequence, connected by thin lines that trace the flow of information from context-in to memory-out. The visual language is borrowed from network waterfalls and flame charts -- familiar territory for developers who have debugged HTTP requests and profiled rendering pipelines. The metaphor transfers cleanly: instead of packets and frames, you are watching memories move through a cognitive pipeline.
  </p>
  <p>
    The first step shows the raw context: the input that triggered memory retrieval. "About to deploy auth service to production." This is what the agent knew about the current moment. Below it, the embedding -- a small bar chart visualization of the high-dimensional vector that represents the semantic content of this context. You cannot read a 1536-dimensional vector, but you can see its shape, and over time you develop an intuition for what different shapes correspond to.
  </p>
  <p>
    Then the search results. Five candidate memories, ranked by cosine similarity. The top three glow green -- they cleared the threshold. The fourth is dim, below the line. The fifth is nearly invisible, a memory about team standups that has no business being near a deployment context but was returned by the vector search anyway. This is the reality of semantic retrieval: it returns neighbors, and not all neighbors are relevant.
  </p>
  <p>
    The threshold step draws a clean line. Above: injected. Below: filtered. And then the injection itself -- the formatted prompt fragment that was actually sent to the model. This is the moment of truth. These are the exact words, in the exact order, that shaped the agent's behavior.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>
  <p>
    The debugger answers a question that is currently unanswerable in most agent systems: <strong>why did the agent behave the way it did?</strong>
  </p>
  <p>
    When an agent makes a mistake, there are several possible explanations. It might have bad memories -- incorrect information stored as learnings. It might have good memories that failed to surface -- the right knowledge exists but the similarity score was too low for the current context. It might have the right memories injected but the model ignored them. Or the threshold might be miscalibrated, filtering out relevant context.
  </p>
  <p>
    Without a debugger, these failure modes are indistinguishable. The agent did the wrong thing, and you have no way to determine whether the problem is in storage, retrieval, injection, or interpretation. With the debugger, each stage of the pipeline is visible. You can see the candidate pool. You can see the scores. You can see what crossed the threshold and what did not.
  </p>
  <p>
    The "What if?" slider makes this concrete. Drag the threshold down to 0.45, and the monitoring memory passes through. Would that have changed the outcome? Drag it up to 0.75, and the feature flags memory gets filtered. Would stricter filtering have been better? The slider turns a fixed parameter into an explorable dimension, letting you understand the sensitivity of the system to its configuration.
  </p>
  <p>
    The final step -- new learnings stored, confidences boosted -- closes the loop. Memory is not just an input to runs; it is also an output. The debugger shows both directions, making the full cycle visible: memories shape behavior, and behavior shapes memories.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>
  <p>
    The debugger requires instrumentation on the <code>/inject</code> endpoint. Today, inject takes a context string and returns the memories to include. For the debugger to work, inject needs to also return the full candidate pool with similarity scores, the scopes searched, the threshold applied, and the embedding used for the search.
  </p>
  <p>
    This is a structured trace, similar to what OpenTelemetry provides for distributed systems. Each inject call would produce a trace document:
  </p>
  <pre><code set:html={`{
  "run_id": "run_1847_a3f8c",
  "context": "about to deploy auth service...",
  "embedding": [0.823, 0.412, ...],
  "candidates": [
    { "content": "always run dry-run...", "score": 0.92, "passed": true },
    { "content": "check migration state...", "score": 0.87, "passed": true },
    ...
  ],
  "threshold": 0.65,
  "injected_count": 3,
  "duration_ms": 89
}`} /></pre>
  <p>
    The learning side is already captured. When <code>/learn</code> is called at the end of a run, deja stores the new learnings with timestamps and confidence scores. The debugger simply correlates learn events with the inject trace from the same run.
  </p>
  <p>
    Storage overhead is manageable. The candidate pool is small (typically 5-20 memories), and the trace metadata is lightweight. Storing traces for every inject call would be excessive for high-volume production use, but a sampling strategy -- or explicit opt-in per run -- makes it practical.
  </p>
  <p>
    The embedding visualization is a simplification. Showing 10 bars for a 1536-dimensional vector requires dimensionality reduction -- PCA or t-SNE projected down to a handful of components. This is imprecise but useful: it gives the viewer a sense of the vector's "shape" without requiring them to understand high-dimensional geometry.
  </p>

  <h2 id="design-tensions">Design tensions</h2>
  <p>
    The debugger is printf debugging for agent cognition. The phrase is deliberately provocative. Printf debugging is considered primitive, a last resort when proper tooling fails. But for agent memory, we do not yet have proper tooling. The state of the art is "check the logs and hope." The debugger provides structured observability where today there is none.
  </p>
  <p>
    There is a tension between completeness and comprehensibility. The full trace of a memory injection includes the embedding vector (1536 floats), the candidate pool (potentially dozens of memories with full content), the scoring function internals, and the injection template. Showing all of this at once would overwhelm. The progressive disclosure pattern -- summary first, click to expand -- is essential. The waterfall should be glanceable at the top level and detailed at the expanded level.
  </p>
  <p>
    The "What if?" slider introduces a deeper tension. It lets you explore counterfactual thresholds, which is useful for understanding sensitivity. But it can also create false confidence. Seeing that a lower threshold would have included a relevant memory does not mean a lower threshold would have produced better behavior overall -- it might also include more noise. The slider is a tool for exploration, not optimization.
  </p>
  <p>
    Timing information adds a practical dimension. If embedding generation takes 200ms and search takes 500ms, you know where to focus optimization. If the entire pipeline runs in 50ms, latency is not the problem. The waterfall makes performance characteristics visible alongside semantic ones.
  </p>

  <h2 id="why-essential">Why this is essential</h2>
  <p>
    When a traditional software system produces an incorrect result, you have well-established tools for diagnosis. You read the code. You step through the debugger. You examine the inputs and trace the logic. The causal chain from input to output is, in principle, fully observable.
  </p>
  <p>
    When an agent system produces an incorrect result, a significant portion of the causal chain is invisible. The model's internal reasoning is opaque. But the memory injection -- the external context that was provided to the model -- is fully within our control and fully observable. If we choose to instrument it.
  </p>
  <p>
    The memory debugger makes that choice concrete. It says: we will record what memories were available, what scored highest, what was injected, and what was learned. We will make this trace accessible to humans. And we will provide tools to explore counterfactuals -- what if the threshold were different, what if the scope were broader, what if the memory that was filtered had been included?
  </p>
  <p>
    This is not a complete solution to agent interpretability. The model's internal processing remains a black box. But it addresses the part of the system that we can observe and control. When an agent does something wrong, the first question should not be "what is the model doing?" but "what memories did we give it?" The debugger answers the second question comprehensively.
  </p>
  <p>
    Without this tool, memory-augmented agents operate in an accountability gap. They use stored knowledge to make decisions, but the connection between knowledge and decision is invisible. The debugger closes that gap -- not perfectly, but substantially enough to enable meaningful debugging, optimization, and trust calibration.
  </p>
</ResearchLayout>

<style>
  .debugger-demo {
    box-shadow:
      0 2px 0 var(--color-void-deep),
      0 8px 32px rgba(0, 0, 0, 0.5);
  }

  .waterfall-step {
    opacity: 0;
    transform: translateY(8px);
    animation: step-enter 0.4s ease-out forwards;
  }

  .waterfall-step[data-delay="0"] { animation-delay: 0.1s; }
  .waterfall-step[data-delay="200"] { animation-delay: 0.3s; }
  .waterfall-step[data-delay="400"] { animation-delay: 0.5s; }
  .waterfall-step[data-delay="600"] { animation-delay: 0.7s; }
  .waterfall-step[data-delay="800"] { animation-delay: 0.9s; }
  .waterfall-step[data-delay="1000"] { animation-delay: 1.1s; }

  @keyframes step-enter {
    from {
      opacity: 0;
      transform: translateY(8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .memory-candidate {
    transition: opacity 0.3s ease, transform 0.3s ease;
  }

  .memory-candidate.filtered {
    opacity: 0.25;
    transform: translateX(4px);
  }

  .memory-candidate.passed {
    opacity: 1;
    transform: translateX(0);
  }

  .threshold-range {
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--color-steel);
    border-radius: 2px;
    outline: none;
  }

  .threshold-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--color-brass);
    border: 2px solid var(--color-void-deep);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(201, 169, 97, 0.3);
  }

  .threshold-range::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--color-brass);
    border: 2px solid var(--color-void-deep);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(201, 169, 97, 0.3);
  }

  .step-header:hover .step-expand {
    color: var(--color-brass);
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Threshold slider
    const slider = document.getElementById('threshold-slider') as HTMLInputElement;
    const thresholdValue = document.getElementById('threshold-value');
    const thresholdResult = document.getElementById('threshold-result');
    const thresholdLabel = document.getElementById('threshold-label');
    const passCount = document.getElementById('pass-count');
    const candidates = document.querySelectorAll('.memory-candidate');

    function updateThreshold(value: number) {
      const threshold = value / 100;
      if (thresholdValue) thresholdValue.textContent = threshold.toFixed(2);
      if (thresholdLabel) thresholdLabel.textContent = threshold.toFixed(2);

      let passed = 0;
      let filtered = 0;

      candidates.forEach(candidate => {
        const score = parseInt(candidate.getAttribute('data-score') || '0');
        if (score >= value) {
          candidate.classList.remove('filtered');
          candidate.classList.add('passed');
          passed++;
        } else {
          candidate.classList.add('filtered');
          candidate.classList.remove('passed');
          filtered++;
        }
      });

      if (thresholdResult) thresholdResult.textContent = `${passed} memor${passed === 1 ? 'y' : 'ies'} pass`;
      if (passCount) passCount.textContent = `${passed} passed, ${filtered} filtered`;
    }

    if (slider) {
      slider.addEventListener('input', () => {
        updateThreshold(parseInt(slider.value));
      });
      updateThreshold(65);
    }

    // Expandable steps
    const steps = document.querySelectorAll('.waterfall-step');
    steps.forEach(step => {
      const header = step.querySelector('.step-header');
      const detail = step.querySelector('.step-detail');
      const preview = step.querySelector('.step-preview');
      const expand = step.querySelector('.step-expand');

      if (header && detail) {
        header.addEventListener('click', () => {
          const isOpen = !detail.classList.contains('hidden');
          if (isOpen) {
            detail.classList.add('hidden');
            if (preview) preview.classList.remove('hidden');
            if (expand) expand.textContent = '+';
          } else {
            detail.classList.remove('hidden');
            if (preview) preview.classList.add('hidden');
            if (expand) expand.textContent = '-';
          }
        });
      }
    });
  });
</script>
