---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('deja-vu-moment')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="demo-deja-vu-wrapper bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Header bar -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10">
        <div class="flex items-center gap-3">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/60">Push Recall Simulator</span>
        </div>
        <div class="flex items-center gap-3">
          <label class="font-mono text-[10px] text-chrome-dark/40">Confidence threshold:</label>
          <input id="threshold-slider" type="range" min="0" max="100" value="50" class="threshold-slider w-24 h-1 accent-[#c9a961]" />
          <span id="threshold-value" class="font-mono text-[10px] text-brass w-8 text-right">0.50</span>
        </div>
      </div>

      <div class="relative">
        <!-- Code editor area -->
        <div class="px-5 py-4 border-b border-brass/10">
          <div class="font-mono text-[10px] text-chrome-dark/30 mb-2">deploy.sh</div>
          <div class="code-editor bg-void rounded-sm border border-steel-light/30 p-4 font-mono text-[13px] leading-relaxed">
            <div class="code-line"><span class="text-chrome-dark/30">1</span>  <span class="text-[#7cacb5]">#!/bin/bash</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">2</span>  <span class="text-chrome-dark/50"># Production deployment script</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">3</span>  <span class="text-[#c9a961]">export</span> <span class="text-chrome">DEPLOY_ENV</span><span class="text-chrome-dark/50">=</span><span class="text-[#8bba7f]">"production"</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">4</span>  <span class="text-chrome">echo</span> <span class="text-[#8bba7f]">"Building for </span><span class="text-[#c9a961]">$DEPLOY_ENV</span><span class="text-[#8bba7f]">..."</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">5</span>  <span class="text-chrome">npm</span> <span class="text-chrome-dark">run</span> <span class="text-chrome-dark">build</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">6</span></div>
            <div class="code-line"><span class="text-chrome-dark/30">7</span>  <span class="text-chrome-dark/50"># Deploy to Cloudflare</span></div>
            <div class="code-line highlight-line"><span class="text-chrome-dark/30">8</span>  <span id="deploy-command" class="text-chrome"></span><span id="cursor-blink" class="cursor-char">|</span></div>
          </div>
        </div>

        <!-- Terminal area -->
        <div class="px-5 py-4 bg-void/50">
          <div class="font-mono text-[10px] text-chrome-dark/30 mb-2">terminal</div>
          <div class="terminal-area bg-void rounded-sm border border-steel-light/30 p-4 font-mono text-[13px] min-h-[60px]">
            <div class="flex items-center gap-2">
              <span class="text-[#8bba7f]">$</span>
              <span id="terminal-text" class="text-chrome"></span>
              <span id="terminal-cursor" class="cursor-char">|</span>
            </div>
            <div id="terminal-output" class="text-chrome-dark/50 mt-1 hidden"></div>
          </div>
        </div>

        <!-- Notification area (slides in from right) -->
        <div id="notifications" class="absolute top-4 right-4 w-80 flex flex-col gap-3 z-10 pointer-events-none">
          <!-- Primary notification -->
          <div id="notif-primary" class="notification-card hidden pointer-events-auto bg-steel border border-brass/30 rounded-sm shadow-lg shadow-black/40 overflow-hidden">
            <div class="h-px bg-gradient-to-r from-brass/40 via-brass/60 to-brass/40"></div>
            <div class="p-4">
              <div class="flex items-center gap-2 mb-2">
                <div class="w-1.5 h-1.5 rounded-full bg-brass animate-pulse"></div>
                <span class="font-serif-sc text-[13px] font-bold text-brass">You've been here before</span>
              </div>
              <p class="font-serif text-[12px] text-chrome-dark leading-relaxed m-0 mb-3">
                Last time you deployed to production, you learned: <span class="text-chrome">always run --dry-run first</span> to catch config errors before they hit live.
              </p>
              <div class="flex items-center gap-3 mb-3">
                <span class="font-mono text-[9px] text-brass/70">confidence: 0.92</span>
                <span class="font-mono text-[9px] text-chrome-dark/40">recalled 3 times</span>
              </div>
              <div class="flex items-center gap-2">
                <button class="notif-dismiss font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-chrome-dark/50 hover:text-chrome hover:border-brass/30 transition-colors">
                  Dismiss
                </button>
                <button class="notif-more font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-brass/70 hover:text-brass hover:border-brass/40 transition-colors">
                  Show more
                </button>
                <button class="notif-snooze font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-chrome-dark/40 hover:text-chrome-dark/60 hover:border-brass/20 transition-colors">
                  Snooze
                </button>
              </div>
            </div>
          </div>

          <!-- Secondary notification -->
          <div id="notif-secondary" class="notification-card hidden pointer-events-auto bg-steel border border-brass/15 rounded-sm shadow-lg shadow-black/40 overflow-hidden">
            <div class="h-px bg-gradient-to-r from-brass/20 via-brass/30 to-brass/20"></div>
            <div class="p-3">
              <div class="flex items-center gap-2 mb-1.5">
                <div class="w-1 h-1 rounded-full bg-brass/50"></div>
                <span class="font-serif text-[11px] text-chrome-dark/70">Related memory</span>
              </div>
              <p class="font-serif text-[11px] text-chrome-dark/60 leading-relaxed m-0 mb-2">
                Check migration state before deploying -- schema mismatches caused a 20-minute rollback last quarter.
              </p>
              <div class="flex items-center gap-3">
                <span class="font-mono text-[9px] text-brass/50">confidence: 0.71</span>
                <span class="font-mono text-[9px] text-chrome-dark/30">recalled once</span>
              </div>
            </div>
          </div>

          <!-- Third notification (hidden by threshold) -->
          <div id="notif-tertiary" class="notification-card hidden pointer-events-auto bg-steel border border-steel-light/30 rounded-sm shadow-lg shadow-black/40 overflow-hidden">
            <div class="h-px bg-gradient-to-r from-chrome-dark/10 via-chrome-dark/20 to-chrome-dark/10"></div>
            <div class="p-3">
              <div class="flex items-center gap-2 mb-1.5">
                <div class="w-1 h-1 rounded-full bg-chrome-dark/30"></div>
                <span class="font-serif text-[11px] text-chrome-dark/40">Faint recall</span>
              </div>
              <p class="font-serif text-[11px] text-chrome-dark/40 leading-relaxed m-0 mb-2">
                The staging deploy key expires quarterly -- might be worth checking before prod.
              </p>
              <div class="flex items-center gap-3">
                <span class="font-mono text-[9px] text-chrome-dark/30">confidence: 0.38</span>
                <span class="font-mono text-[9px] text-chrome-dark/20">never recalled</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <div class="px-5 py-2.5 border-t border-brass/10 flex items-center justify-between">
        <span class="font-mono text-[10px] text-chrome-dark/30">Memories surface when context matches. Adjust the threshold to filter by confidence.</span>
        <button id="replay-btn" class="font-mono text-[10px] px-2.5 py-1 rounded-sm border border-brass/20 text-chrome-dark/50 hover:text-brass hover:border-brass/40 transition-colors">
          Replay
        </button>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#critical-question" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Critical question</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>
  <p>
    You are not looking for a memory. You are writing code, focused, deep in the deployment script you have edited a dozen times. Your fingers type the familiar command -- <code>wrangler deploy --env production</code> -- and in your peripheral vision, a card appears. It slides in from the right edge of the screen, quiet but present. A warm brass border. A small pulsing dot. The header reads: "You've been here before."
  </p>
  <p>
    This is the deja vu moment. Not a search result. Not a dashboard you navigated to. A memory that found you. The card tells you something specific: the last time you ran this exact command, you learned to do a dry run first. It tells you the confidence level of that memory (high), how many times it has been recalled (three), and when it was last relevant (last week). It is not demanding your attention. It is offering it.
  </p>
  <p>
    Two seconds later, a second card appears below the first. Smaller, quieter, a more muted border. "Related: check migration state before deploying." This one is lower confidence, recalled only once. It is a whisper where the first was a clear voice. You glance at it, nod, and return to your work. Or you dismiss both and keep going. The system does not insist.
  </p>
  <p>
    The experience is designed to feel like intuition externalized. When an experienced developer pauses before a deployment, they are recalling something -- a past incident, a best practice, a lesson learned. The deja vu moment takes that internal recall and makes it visible. The difference is that the agent's memory is explicit and inspectable, whereas human intuition is opaque even to the person experiencing it.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>
  <p>
    The fundamental insight of push-based recall is that relevance is contextual and temporal. A memory about deployment best practices is maximally relevant when you are deploying. It is noise when you are writing tests. Traditional memory interfaces -- tables, search bars, dashboards -- require you to leave your context and enter a retrieval mode. You stop writing code, open the memory interface, search for what you vaguely remember, scan results, find the relevant entry, read it, close the interface, return to your code. The context switch costs more than the knowledge is worth.
  </p>
  <p>
    Push-based recall eliminates the context switch. The system monitors your current context -- the file you are editing, the command you are typing, the conversation you are having -- and matches it against stored memories in real time. When a match exceeds a confidence threshold, a notification appears. You never leave your flow. The memory comes to you.
  </p>
  <p>
    This reveals a distinction that matters: the difference between a library and a friend who remembers. A library has all the answers, but you have to go there, know what to look for, and find it yourself. A friend who remembers notices that you are about to make a mistake and says, "Hey, last time you did that, remember what happened?" The library is more comprehensive. The friend is more useful. Push-based recall turns your agent's memory into the friend.
  </p>
  <p>
    It also reveals the importance of timing. The same memory delivered five minutes before you need it is noise. Delivered at the moment of action, it is insight. The deja vu interface is fundamentally about temporal precision: surfacing the right knowledge at the right moment, and only then.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>
  <p>
    Deja already has a mechanism for pushing memories into agent context. The <code>/inject</code> endpoint takes a context string and returns semantically matched learnings, which are then injected into the agent's system prompt. This is push-based recall at the API level -- the agent does not search for memories, memories are delivered to it based on what it is currently doing.
  </p>
  <p>
    The deja vu interface extends this pattern from agent-facing to human-facing. Instead of injecting memories into a system prompt, you inject them into the developer's visual field. The mechanism is the same: semantic matching against current context. The delivery channel is different: a notification card instead of a prompt block.
  </p>
  <p>
    Implementation could take several forms. An IDE plugin that watches the current file and terminal, sends the context to deja's matching endpoint, and renders notifications when matches exceed a threshold. A CLI hook that intercepts commands before execution and queries deja for relevant memories. A browser extension that monitors the current page and overlays memory cards. Each is a different surface for the same underlying capability: context-driven recall.
  </p>
  <p>
    The confidence threshold becomes a critical UX control. In the demo above, the slider filters which memories surface. Set it high (0.8+) and you only see strong, well-confirmed memories. Set it low (0.3) and you see every faint association. The right default depends on the user: someone new to a codebase might want low thresholds to surface everything the agent knows. An experienced developer might only want high-confidence interruptions.
  </p>

  <h2 id="design-tensions">Design tensions</h2>
  <p>
    The dominant tension is notification fatigue. Every notification system in history has faced this: the more you show, the less people look. Email became spam. Slack became noise. Push notifications became the thing everyone disables. Any push-based memory system is one bad threshold away from the same fate.
  </p>
  <p>
    The defenses are several. First, confidence acts as a natural filter. Deja's confidence scores already encode how reliable a memory is. Only surfacing high-confidence memories means fewer, more trustworthy notifications. Second, recall count provides a proxy for importance: a memory recalled eight times is probably more worth showing than one recalled never. Third, recency matters: a memory from yesterday's session is more likely relevant than one from six months ago.
  </p>
  <p>
    But even well-filtered notifications can overwhelm if they are poorly timed. The system needs to understand not just what matches semantically but whether the user is in a state to receive information. Mid-keystroke is bad. After hitting enter is better. During a pause is best. The deja vu moment should feel like a thought arriving, not an interruption imposed.
  </p>
  <p>
    There is also the question of trust. When a notification says "you've been here before," the user needs to believe it. A false positive -- a memory surfaced that is irrelevant or wrong -- does not just waste time. It erodes trust in the entire system. One bad recommendation and the user starts ignoring all of them. This means the matching algorithm needs to be conservative by default, trading recall for precision.
  </p>
  <p>
    The dismiss, show more, and snooze buttons in the demo are not decorative. They are feedback mechanisms. Dismiss means "not relevant right now." Snooze means "relevant but not now." Show more means "tell me everything." Each action teaches the system about the user's preferences, and over time the notifications should calibrate to what the user actually finds useful.
  </p>

  <h2 id="critical-question">Critical question</h2>
  <p>
    The question at the heart of this interface is: how do you train people to trust ambient recall without overwhelming them? This is not a technical question. It is a behavioral one. People have learned, through years of bad notification design, to distrust anything that interrupts their flow. Pop-ups are dismissed. Banners are ignored. Notifications are muted.
  </p>
  <p>
    To overcome this learned distrust, push-based recall needs to be right more often than it is wrong. It needs to arrive at the right time. It needs to be easy to dismiss and hard to resent. And crucially, it needs to deliver value early -- in the first few interactions -- before the user has a chance to develop the habit of ignoring it.
  </p>
  <p>
    The most promising approach is to start with the highest-confidence, most clearly relevant memories and expand gradually. Show only the memory that matches with 0.95 confidence on the exact command being typed. If the user finds that useful, lower the threshold. If they engage with the "show more" button, surface related memories. If they dismiss repeatedly, back off. The system should be adaptive, not static. The goal is not to show all relevant memories. The goal is to show exactly the memories that the user would have wished they had remembered.
  </p>
  <p>
    There is something deeper here too: the relationship between memory and attention. Human memory is not a retrieval system. It is an attention system. We do not remember everything and retrieve selectively. We notice selectively and remember what we noticed. The deja vu interface attempts to do the same thing for agent memory: not showing everything the agent knows, but directing the human's attention to the one thing worth noticing right now.
  </p>
</ResearchLayout>

<style>
  .code-editor {
    line-height: 1.7;
    overflow-x: auto;
  }

  .code-line {
    display: flex;
    gap: 1rem;
    white-space: nowrap;
  }

  .code-line span:first-child {
    width: 1.2em;
    text-align: right;
    user-select: none;
    flex-shrink: 0;
  }

  .highlight-line {
    background: rgba(201, 169, 97, 0.05);
    margin: 0 -1rem;
    padding: 0 1rem;
    border-left: 2px solid rgba(201, 169, 97, 0.3);
  }

  .cursor-char {
    animation: cursor-blink 1s step-end infinite;
    color: #c9a961;
    font-weight: 100;
  }

  @keyframes cursor-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  .notification-card {
    transform: translateX(120%);
    opacity: 0;
    transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.5s ease;
  }

  .notification-card.visible {
    transform: translateX(0);
    opacity: 1;
  }

  .notification-card.dismissed {
    transform: translateX(120%);
    opacity: 0;
    transition: transform 0.3s ease-in, opacity 0.3s ease-in;
  }

  .threshold-slider {
    -webkit-appearance: none;
    appearance: none;
    height: 2px;
    background: rgba(201, 169, 97, 0.2);
    border-radius: 1px;
    outline: none;
  }

  .threshold-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #c9a961;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  .threshold-slider::-moz-range-thumb {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #c9a961;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  .terminal-area {
    min-height: 50px;
  }
</style>

<script>
  const editorCommand = 'wrangler deploy --env production';
  const terminalCommand = 'wrangler deploy --env production';

  let animationRunning = false;
  let animationTimeouts: number[] = [];

  const notifConfidences = {
    primary: 0.92,
    secondary: 0.71,
    tertiary: 0.38,
  };

  function resetDemo() {
    animationTimeouts.forEach(t => clearTimeout(t));
    animationTimeouts = [];
    animationRunning = false;

    const deployCmd = document.getElementById('deploy-command')!;
    const terminalText = document.getElementById('terminal-text')!;
    const terminalOutput = document.getElementById('terminal-output')!;
    const cursorBlink = document.getElementById('cursor-blink')!;
    const terminalCursor = document.getElementById('terminal-cursor')!;

    deployCmd.textContent = '';
    terminalText.textContent = '';
    terminalOutput.classList.add('hidden');
    cursorBlink.style.display = 'inline';
    terminalCursor.style.display = 'none';

    document.querySelectorAll('.notification-card').forEach(card => {
      card.classList.remove('visible', 'dismissed');
      card.classList.add('hidden');
    });
  }

  function typeText(element: HTMLElement, text: string, baseDelay: number, callback?: () => void) {
    let i = 0;
    function typeChar() {
      if (i < text.length) {
        element.textContent += text[i];
        i++;
        const jitter = Math.random() * 60 - 30;
        const delay = baseDelay + jitter + (text[i - 1] === ' ' ? 80 : 0);
        const t = window.setTimeout(typeChar, delay);
        animationTimeouts.push(t);
      } else if (callback) {
        callback();
      }
    }
    typeChar();
  }

  function showNotification(id: string) {
    const threshold = parseFloat((document.getElementById('threshold-slider') as HTMLInputElement).value) / 100;
    const card = document.getElementById(id);
    if (!card) return;

    const conf = notifConfidences[id.replace('notif-', '') as keyof typeof notifConfidences];
    if (conf < threshold) return;

    card.classList.remove('hidden', 'dismissed');
    // Force reflow before adding visible class
    void card.offsetHeight;
    card.classList.add('visible');
  }

  function runAnimation() {
    if (animationRunning) return;
    resetDemo();
    animationRunning = true;

    const deployCmd = document.getElementById('deploy-command')!;
    const terminalText = document.getElementById('terminal-text')!;
    const terminalOutput = document.getElementById('terminal-output')!;
    const cursorBlink = document.getElementById('cursor-blink')!;
    const terminalCursor = document.getElementById('terminal-cursor')!;

    // Phase 1: Type in the editor
    typeText(deployCmd, editorCommand, 55, () => {
      // Phase 2: After editor typing, switch focus to terminal
      const t1 = window.setTimeout(() => {
        cursorBlink.style.display = 'none';
        terminalCursor.style.display = 'inline';

        // Phase 3: Type in terminal
        typeText(terminalText, terminalCommand, 65, () => {
          // Show primary notification when command is mostly typed
        });
      }, 600);
      animationTimeouts.push(t1);
    });

    // Show primary notification midway through typing
    const t2 = window.setTimeout(() => {
      showNotification('notif-primary');
    }, editorCommand.length * 55 + 800);
    animationTimeouts.push(t2);

    // Show secondary notification 2 seconds after primary
    const t3 = window.setTimeout(() => {
      showNotification('notif-secondary');
    }, editorCommand.length * 55 + 2800);
    animationTimeouts.push(t3);

    // Show tertiary notification 1.5 seconds after secondary
    const t4 = window.setTimeout(() => {
      showNotification('notif-tertiary');
    }, editorCommand.length * 55 + 4300);
    animationTimeouts.push(t4);

    // Show terminal output after typing completes
    const totalTypingTime = editorCommand.length * 55 + 600 + terminalCommand.length * 65 + 500;
    const t5 = window.setTimeout(() => {
      terminalOutput.classList.remove('hidden');
      terminalOutput.innerHTML = '<span class="text-chrome-dark/40">Deploying to production...</span>';
      animationRunning = false;
    }, totalTypingTime);
    animationTimeouts.push(t5);
  }

  // Threshold slider
  const slider = document.getElementById('threshold-slider') as HTMLInputElement;
  const thresholdLabel = document.getElementById('threshold-value')!;

  slider?.addEventListener('input', () => {
    const val = parseInt(slider.value) / 100;
    thresholdLabel.textContent = val.toFixed(2);

    // Update visibility of existing notifications
    Object.entries(notifConfidences).forEach(([key, conf]) => {
      const card = document.getElementById(`notif-${key}`);
      if (!card) return;
      if (card.classList.contains('visible') && conf < val) {
        card.classList.remove('visible');
        card.classList.add('dismissed');
        setTimeout(() => card.classList.add('hidden'), 300);
      }
    });
  });

  // Dismiss buttons
  document.querySelectorAll('.notif-dismiss').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const card = (e.target as HTMLElement).closest('.notification-card');
      if (card) {
        card.classList.remove('visible');
        card.classList.add('dismissed');
        setTimeout(() => card.classList.add('hidden'), 300);
      }
    });
  });

  // Snooze buttons
  document.querySelectorAll('.notif-snooze').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const card = (e.target as HTMLElement).closest('.notification-card');
      if (card) {
        card.classList.remove('visible');
        card.classList.add('dismissed');
        setTimeout(() => card.classList.add('hidden'), 300);
      }
    });
  });

  // Show more buttons
  document.querySelectorAll('.notif-more').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const card = (e.target as HTMLElement).closest('.notification-card');
      if (card) {
        const body = card.querySelector('p');
        if (body && !body.dataset.expanded) {
          body.dataset.expanded = 'true';
          body.innerHTML = body.innerHTML + '<br/><br/><span class="text-chrome-dark/50">Source: session with deploy-agent on 2025-01-14. Triggered during a failed production deploy that required rollback. The --dry-run flag would have caught the misconfigured environment variable before it reached live traffic.</span>';
        }
      }
    });
  });

  // Replay button
  document.getElementById('replay-btn')?.addEventListener('click', () => {
    runAnimation();
  });

  // Initial run
  const t = setTimeout(() => runAnimation(), 800);
  animationTimeouts.push(t);
</script>
