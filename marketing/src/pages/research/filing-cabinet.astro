---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('filing-cabinet')!;
---

<ResearchLayout concept={concept}>
  <!-- Demo -->
  <div slot="demo">
    <div class="filing-cabinet-demo bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Toolbar -->
      <div class="flex items-center justify-between px-4 py-3 border-b border-brass/10 bg-steel/50">
        <div class="flex items-center gap-3">
          <input
            type="text"
            id="fc-search"
            placeholder="Search memories..."
            class="bg-void border border-brass/15 rounded-sm px-3 py-1.5 text-[13px] font-mono text-chrome placeholder:text-chrome-dark/30 focus:outline-none focus:border-brass/40 w-56 transition-colors"
          />
          <div class="flex items-center gap-0.5 ml-2" id="fc-scope-tabs">
            <button data-scope="all" class="fc-scope-tab active font-mono text-[10px] tracking-wider uppercase px-2.5 py-1 rounded-sm transition-colors">All</button>
            <button data-scope="shared" class="fc-scope-tab font-mono text-[10px] tracking-wider uppercase px-2.5 py-1 rounded-sm transition-colors">Shared</button>
            <button data-scope="agent" class="fc-scope-tab font-mono text-[10px] tracking-wider uppercase px-2.5 py-1 rounded-sm transition-colors">Agent</button>
            <button data-scope="session" class="fc-scope-tab font-mono text-[10px] tracking-wider uppercase px-2.5 py-1 rounded-sm transition-colors">Session</button>
          </div>
        </div>
        <div class="flex items-center gap-2">
          <span id="fc-count" class="font-mono text-[10px] text-chrome-dark/40">10 memories</span>
          <button id="fc-delete-btn" class="font-mono text-[10px] tracking-wider uppercase px-2.5 py-1 rounded-sm bg-red-900/30 text-red-400/60 border border-red-500/15 cursor-not-allowed opacity-50 transition-all">Delete selected</button>
        </div>
      </div>

      <!-- Table -->
      <div class="overflow-x-auto">
        <table class="w-full text-left" id="fc-table">
          <thead>
            <tr class="border-b border-brass/10">
              <th class="px-4 py-2.5 w-8">
                <input type="checkbox" id="fc-select-all" class="fc-checkbox" />
              </th>
              <th class="fc-sortable px-4 py-2.5 font-mono text-[10px] font-bold tracking-widest uppercase text-chrome-dark/40 cursor-pointer hover:text-brass/70 transition-colors select-none" data-sort="trigger">
                Trigger <span class="fc-sort-arrow"></span>
              </th>
              <th class="fc-sortable px-4 py-2.5 font-mono text-[10px] font-bold tracking-widest uppercase text-chrome-dark/40 cursor-pointer hover:text-brass/70 transition-colors select-none" data-sort="learning">
                Learning <span class="fc-sort-arrow"></span>
              </th>
              <th class="fc-sortable px-4 py-2.5 font-mono text-[10px] font-bold tracking-widest uppercase text-chrome-dark/40 cursor-pointer hover:text-brass/70 transition-colors select-none whitespace-nowrap" data-sort="confidence">
                Confidence <span class="fc-sort-arrow"></span>
              </th>
              <th class="fc-sortable px-4 py-2.5 font-mono text-[10px] font-bold tracking-widest uppercase text-chrome-dark/40 cursor-pointer hover:text-brass/70 transition-colors select-none" data-sort="scope">
                Scope <span class="fc-sort-arrow"></span>
              </th>
              <th class="fc-sortable px-4 py-2.5 font-mono text-[10px] font-bold tracking-widest uppercase text-chrome-dark/40 cursor-pointer hover:text-brass/70 transition-colors select-none" data-sort="date">
                Date <span class="fc-sort-arrow"></span>
              </th>
            </tr>
          </thead>
          <tbody id="fc-tbody">
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ToC -->
  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#technical-implementation" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Technical implementation</a>
  </Fragment>

  <!-- Content -->
  <h2 id="the-experience">The experience</h2>

  <p>You open the dashboard. It loads in under a second. There they are: all 347 memories your deployment agent has accumulated over the past three months, rendered as rows in a table. Each row is a discrete unit of knowledge -- a trigger on the left, a learning on the right, a confidence score in the middle, a scope label, a date. The familiar grid of spreadsheet cells.</p>

  <p>You type "docker" into the search box. The table filters instantly -- 23 results. You click the confidence column header and the rows rearrange: the most certain memories float to the top. <code>Always use --no-cache for production builds</code> sits at 0.95 confidence. Below it, <code>Pin base images to SHA digests, not tags</code> at 0.91. You know these are solid. Further down, at 0.4, there is a tentative memory about multi-stage builds reducing image size. That one could use verification.</p>

  <p>You switch the scope tab to "Shared." The count drops from 23 to 8. These are the memories that have been promoted from a single agent's experience to organizational knowledge -- the ones any agent can access. You select three outdated memories with checkboxes, click "Delete selected," and they vanish. Bulk operations on knowledge. It feels efficient. It feels a little uncomfortable.</p>

  <p>There is a completeness to this view that no other interface offers. You can see everything. You can sort on any axis. You could export the whole table to CSV if you wanted to run analysis in a spreadsheet. This is memory as data management -- the admin panel for cognition.</p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>The filing cabinet reveals everything literally and nothing structurally. Every memory is visible, which is genuinely useful for auditing. You can answer questions like: How many memories does this agent have? What is the average confidence? Are there duplicates? When was the last memory stored? These are operational questions, and the filing cabinet answers them instantly.</p>

  <p>But a table treats every row as an island. The memory about docker cache flags sits next to the memory about Kubernetes health checks, separated by nothing more meaningful than alphabetical order or a timestamp. There is no way to see that these two memories were born from the same failed deployment, that they are siblings in a causal chain. The table shows <em>what</em> without showing <em>why</em> or <em>when it mattered</em>.</p>

  <p>This is the fundamental limitation of tabular memory: it optimizes for enumeration at the expense of meaning. A memory is not a row. It is an event that happened in a context, connected to other events, decaying or strengthening over time. The filing cabinet strips all of that away, leaving only the atomic content and a handful of metadata fields.</p>

  <p>And yet, this is not a criticism. Every system needs its admin view. The filing cabinet is where you go when something is wrong -- when you need to find a specific memory, delete a batch of stale data, or verify that a particular piece of knowledge was actually stored. It is the debugger's entry point. Just not the user's daily interface.</p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>The filing cabinet maps directly to deja's existing <code>/learnings</code> endpoint with scope filters. The API already supports listing, searching, and deleting learnings by scope. A minimal implementation would call <code>GET /learnings?scope=shared&limit=100</code> and render the results in a sortable table. This is, almost trivially, a weekend project.</p>

  <p>The scope tabs map to deja's three-tier scope model: <code>session</code>, <code>agent</code>, and <code>shared</code>. Each is a query parameter. The confidence scores are already stored as floats between 0 and 1. The trigger and learning fields are first-class properties of every learning object. Even the date column maps cleanly to <code>created_at</code>.</p>

  <p>Search is where it gets slightly more interesting. A naive implementation does substring matching against trigger and learning text. But deja also exposes <code>/inject</code>, which performs semantic search against the vector embeddings. The filing cabinet could offer both: a fast text filter for exact matches and a "semantic search" toggle that queries the embedding space. The latter is more powerful but also more opaque -- you might not understand why a particular result appeared.</p>

  <p>Bulk operations require multiple API calls. Deleting ten memories means ten <code>DELETE /learnings/:id</code> requests. There is no batch endpoint today. This is a design choice worth revisiting if the filing cabinet becomes a primary interface, because bulk operations are exactly what tables are good for.</p>

  <h2 id="design-tensions">Design tensions</h2>

  <p>The deepest tension in the filing cabinet is that memory is not tabular. Representing memories as rows in a table is a lossy compression. You lose the temporal narrative (when did this memory matter?), the causal structure (what led to this memory being stored?), the semantic neighborhood (what other memories live nearby in embedding space?), and the decay dynamics (is this memory still being recalled, or has it gone cold?).</p>

  <p>A filing cabinet also creates a false sense of completeness. When you see 347 rows, you feel like you are seeing everything. But the most important thing about a knowledge base is often what it does <em>not</em> contain -- the gaps, the questions unasked, the domains where no memory has ever been stored. A table cannot show you the shape of absence. It can only show you what exists.</p>

  <p>There is also a governance question. The filing cabinet makes deletion trivially easy. Select, click, gone. But memory deletion in an agent system is not like deleting a spreadsheet row. That memory may have influenced decisions. Other memories may have been stored because of it. Deleting it does not undo its effects -- it just makes the causal chain invisible. The filing cabinet's clean UI obscures this complexity.</p>

  <p>And yet the pull toward this pattern is strong, because it is legible. Stakeholders understand tables. Product managers can review them. Compliance teams can audit them. The filing cabinet speaks the language of existing enterprise tooling, and that is its greatest strength and its most dangerous limitation.</p>

  <h2 id="technical-implementation">Technical implementation</h2>

  <p>A minimal filing cabinet requires three deja API endpoints: <code>GET /learnings</code> for listing, <code>GET /learnings/:id</code> for detail, and <code>DELETE /learnings/:id</code> for removal. The table itself is pure client-side rendering with in-memory sorting and filtering. For a production implementation, you would add server-side pagination, but for the first hundred or so memories, client-side is sufficient and snappier.</p>

  <p>The data model is straightforward. Each row maps to a <code>Learning</code> object:</p>

  <pre><code set:html={`interface Learning {
  id: string;
  trigger: string;
  learning: string;
  confidence: number;
  scope: 'session' | 'agent' | 'shared';
  created_at: string;
  updated_at: string;
  agent_id: string;
}`} /></pre>

  <p>Sorting is a single <code>Array.sort()</code> call with a comparator that switches on the active column. Filtering is a <code>.filter()</code> chain: first by scope (if a tab is active), then by search text (substring match against trigger and learning). The confidence column benefits from a visual treatment -- a colored bar or a numeric badge that shifts from dim to bright as the value approaches 1.0.</p>

  <p>For teams that want CSV export, the entire visible dataset can be serialized client-side using the Blob API. No server round-trip required. This is the filing cabinet's hidden superpower: because it renders everything as flat data, it interoperates perfectly with existing analysis tools. Pipe it into a spreadsheet, run pivot tables, build charts. The filing cabinet does not just display memory -- it makes memory portable.</p>

  <p>The real implementation question is not whether this can be built (it can, quickly) but whether it should be the <em>first</em> thing a user sees. The filing cabinet is a power tool. It rewards users who already know what they are looking for. For discovery, exploration, and understanding, other interfaces in this research series offer something the filing cabinet never will: a sense of shape.</p>
</ResearchLayout>

<style>
  .filing-cabinet-demo {
    font-family: var(--font-mono), monospace;
    max-height: 520px;
  }

  .fc-scope-tab {
    color: rgba(184, 184, 184, 0.4);
    background: transparent;
    border: 1px solid transparent;
  }

  .fc-scope-tab:hover {
    color: rgba(184, 184, 184, 0.7);
    background: rgba(201, 169, 97, 0.05);
  }

  .fc-scope-tab.active {
    color: #c9a961;
    background: rgba(201, 169, 97, 0.1);
    border-color: rgba(201, 169, 97, 0.2);
  }

  .fc-checkbox {
    appearance: none;
    width: 14px;
    height: 14px;
    border: 1px solid rgba(201, 169, 97, 0.2);
    border-radius: 2px;
    background: rgba(10, 10, 10, 0.5);
    cursor: pointer;
    position: relative;
    vertical-align: middle;
  }

  .fc-checkbox:checked {
    background: rgba(201, 169, 97, 0.3);
    border-color: rgba(201, 169, 97, 0.5);
  }

  .fc-checkbox:checked::after {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid #c9a961;
    border-width: 0 1.5px 1.5px 0;
    transform: rotate(45deg);
  }

  #fc-tbody tr {
    border-bottom: 1px solid rgba(201, 169, 97, 0.06);
    transition: background-color 0.15s ease;
  }

  #fc-tbody tr:hover {
    background: rgba(201, 169, 97, 0.03);
  }

  #fc-tbody tr.selected {
    background: rgba(201, 169, 97, 0.06);
  }

  .fc-sort-arrow {
    display: inline-block;
    width: 0;
    height: 0;
    margin-left: 4px;
    vertical-align: middle;
    opacity: 0;
    transition: opacity 0.15s ease;
  }

  .fc-sort-arrow.asc {
    opacity: 0.7;
    border-left: 3.5px solid transparent;
    border-right: 3.5px solid transparent;
    border-bottom: 5px solid #c9a961;
  }

  .fc-sort-arrow.desc {
    opacity: 0.7;
    border-left: 3.5px solid transparent;
    border-right: 3.5px solid transparent;
    border-top: 5px solid #c9a961;
  }

  .fc-confidence-bar {
    display: inline-block;
    height: 4px;
    border-radius: 2px;
    background: linear-gradient(90deg, rgba(155, 126, 60, 0.6), #c9a961);
    vertical-align: middle;
    margin-right: 6px;
  }

  .fc-scope-badge {
    display: inline-block;
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 2px;
  }

  .fc-scope-badge.shared {
    color: #c9a961;
    background: rgba(201, 169, 97, 0.1);
    border: 1px solid rgba(201, 169, 97, 0.15);
  }

  .fc-scope-badge.agent {
    color: #60a5fa;
    background: rgba(96, 165, 250, 0.1);
    border: 1px solid rgba(96, 165, 250, 0.15);
  }

  .fc-scope-badge.session {
    color: rgba(184, 184, 184, 0.5);
    background: rgba(184, 184, 184, 0.05);
    border: 1px solid rgba(184, 184, 184, 0.1);
  }
</style>

<script>
  const memories = [
    { trigger: "Production deployment fails silently", learning: "Always run a dry-run deployment before pushing to production", confidence: 0.92, scope: "shared", date: "2025-02-18" },
    { trigger: "Docker build uses stale layers", learning: "Use --no-cache flag for production Docker builds to ensure fresh layers", confidence: 0.95, scope: "shared", date: "2025-02-17" },
    { trigger: "Kubernetes pod restarts repeatedly", learning: "Set resource limits and configure liveness probes with generous initial delays", confidence: 0.88, scope: "agent", date: "2025-02-16" },
    { trigger: "Test suite takes 40 minutes", learning: "Parallelize test suites by module and cache dependency installations", confidence: 0.79, scope: "agent", date: "2025-02-15" },
    { trigger: "Monitoring gaps during incident", learning: "Configure alerts for p99 latency, error rate, and deployment frequency", confidence: 0.85, scope: "shared", date: "2025-02-14" },
    { trigger: "Staging environment diverges from prod", learning: "Use infrastructure-as-code with identical modules for both environments", confidence: 0.91, scope: "shared", date: "2025-02-13" },
    { trigger: "Secrets committed to repository", learning: "Use pre-commit hooks to scan for secrets and store them in vault", confidence: 0.97, scope: "shared", date: "2025-02-12" },
    { trigger: "Rollback needed during traffic spike", learning: "Maintain blue-green deployment setup for instant rollback capability", confidence: 0.73, scope: "agent", date: "2025-02-11" },
    { trigger: "Database migration breaks downstream", learning: "Run migrations in expand-contract pattern to avoid breaking changes", confidence: 0.66, scope: "session", date: "2025-02-10" },
    { trigger: "Hotfix bypasses normal CI pipeline", learning: "Skip dry-run for hotfixes but require two approvers on the merge request", confidence: 0.41, scope: "session", date: "2025-02-09" },
  ];

  let currentScope = 'all';
  let currentSort = { column: 'date', direction: 'desc' };
  let selectedIds = new Set();

  function getFilteredSorted() {
    let filtered = memories.filter(m => {
      if (currentScope !== 'all' && m.scope !== currentScope) return false;
      const search = (document.getElementById('fc-search') as HTMLInputElement).value.toLowerCase();
      if (search && !m.trigger.toLowerCase().includes(search) && !m.learning.toLowerCase().includes(search)) return false;
      return true;
    });

    filtered.sort((a, b) => {
      const col = currentSort.column as keyof typeof a;
      const dir = currentSort.direction === 'asc' ? 1 : -1;
      if (col === 'confidence') return (a.confidence - b.confidence) * dir;
      const aVal = String(a[col]);
      const bVal = String(b[col]);
      return aVal.localeCompare(bVal) * dir;
    });

    return filtered;
  }

  function render() {
    const tbody = document.getElementById('fc-tbody')!;
    const filtered = getFilteredSorted();

    document.getElementById('fc-count')!.textContent = `${filtered.length} memor${filtered.length === 1 ? 'y' : 'ies'}`;

    tbody.innerHTML = filtered.map((m, i) => {
      const isSelected = selectedIds.has(i);
      const barWidth = Math.round(m.confidence * 40);
      return `<tr class="${isSelected ? 'selected' : ''}" data-idx="${i}">
        <td class="px-4 py-2.5"><input type="checkbox" class="fc-checkbox fc-row-check" data-idx="${i}" ${isSelected ? 'checked' : ''} /></td>
        <td class="px-4 py-2.5 text-[12px] text-chrome-dark/70 max-w-[180px] truncate">${m.trigger}</td>
        <td class="px-4 py-2.5 text-[12px] text-chrome/80 max-w-[260px]">${m.learning}</td>
        <td class="px-4 py-2.5 text-[12px] text-chrome-dark/60 whitespace-nowrap">
          <span class="fc-confidence-bar" style="width: ${barWidth}px; opacity: ${0.4 + m.confidence * 0.6}"></span>
          ${m.confidence.toFixed(2)}
        </td>
        <td class="px-4 py-2.5"><span class="fc-scope-badge ${m.scope}">${m.scope}</span></td>
        <td class="px-4 py-2.5 text-[12px] text-chrome-dark/40 whitespace-nowrap font-mono">${m.date}</td>
      </tr>`;
    }).join('');

    // Update delete button state
    const deleteBtn = document.getElementById('fc-delete-btn') as HTMLButtonElement;
    if (selectedIds.size > 0) {
      deleteBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      deleteBtn.classList.add('cursor-pointer', 'hover:bg-red-900/50');
      deleteBtn.textContent = `Delete selected (${selectedIds.size})`;
    } else {
      deleteBtn.classList.add('opacity-50', 'cursor-not-allowed');
      deleteBtn.classList.remove('cursor-pointer', 'hover:bg-red-900/50');
      deleteBtn.textContent = 'Delete selected';
    }

    // Bind row checkboxes
    tbody.querySelectorAll('.fc-row-check').forEach(cb => {
      cb.addEventListener('change', (e) => {
        const idx = parseInt((e.target as HTMLInputElement).dataset.idx!);
        if ((e.target as HTMLInputElement).checked) {
          selectedIds.add(idx);
        } else {
          selectedIds.delete(idx);
        }
        render();
      });
    });
  }

  // Search
  document.getElementById('fc-search')!.addEventListener('input', () => {
    selectedIds.clear();
    render();
  });

  // Scope tabs
  document.querySelectorAll('.fc-scope-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.fc-scope-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentScope = (tab as HTMLElement).dataset.scope!;
      selectedIds.clear();
      render();
    });
  });

  // Sortable columns
  document.querySelectorAll('.fc-sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = (th as HTMLElement).dataset.sort!;
      if (currentSort.column === col) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.column = col;
        currentSort.direction = 'asc';
      }

      // Update arrows
      document.querySelectorAll('.fc-sort-arrow').forEach(a => {
        a.className = 'fc-sort-arrow';
      });
      const arrow = th.querySelector('.fc-sort-arrow')!;
      arrow.className = `fc-sort-arrow ${currentSort.direction}`;

      render();
    });
  });

  // Select all
  document.getElementById('fc-select-all')!.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    const filtered = getFilteredSorted();
    if (checked) {
      filtered.forEach((_, i) => selectedIds.add(i));
    } else {
      selectedIds.clear();
    }
    render();
  });

  // Delete button
  document.getElementById('fc-delete-btn')!.addEventListener('click', () => {
    if (selectedIds.size === 0) return;
    const indices = Array.from(selectedIds).sort((a, b) => b - a);
    indices.forEach(i => memories.splice(i, 1));
    selectedIds.clear();
    render();
  });

  // Initial render
  render();
</script>
