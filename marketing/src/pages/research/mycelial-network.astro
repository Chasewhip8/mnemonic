---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import DoItWithDeja from '../../components/DoItWithDeja.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('mycelial-network')!;
---

<ResearchLayout concept={concept}>
  <!-- Demo -->
  <div slot="demo">
    <div class="mn-demo bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Toolbar -->
      <div class="flex flex-wrap items-center justify-between gap-2 px-4 py-3 border-b border-brass/10 bg-steel/50">
        <div class="flex items-center gap-3">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/70">Mycelial Network</span>
          <div class="flex items-center gap-2 ml-3">
            <span class="font-mono text-[9px] text-chrome-dark/30">Activate context:</span>
            <input
              type="text"
              id="mn-context-input"
              value="database migration"
              class="bg-void border border-brass/15 rounded-sm px-2.5 py-1 text-[11px] font-mono text-chrome placeholder:text-chrome-dark/30 focus:outline-none focus:border-brass/40 w-44 transition-colors"
            />
            <button id="mn-activate-btn" class="font-mono text-[10px] tracking-wider uppercase px-3 py-1 rounded-sm bg-brass/10 text-brass border border-brass/20 hover:bg-brass/20 transition-all cursor-pointer">Activate</button>
          </div>
          <div class="flex items-center gap-1.5 ml-2 border-l border-brass/10 pl-3">
            <button class="mn-preset-btn font-mono text-[9px] px-2 py-0.5 rounded-sm transition-all cursor-pointer" data-context="database migration">db migration</button>
            <button class="mn-preset-btn font-mono text-[9px] px-2 py-0.5 rounded-sm transition-all cursor-pointer" data-context="API design">API design</button>
            <button class="mn-preset-btn font-mono text-[9px] px-2 py-0.5 rounded-sm transition-all cursor-pointer" data-context="incident response">incident</button>
          </div>
        </div>
        <div class="flex items-center gap-4">
          <div class="flex items-center gap-2">
            <span class="font-mono text-[9px] text-chrome-dark/30">Hops:</span>
            <input type="range" id="mn-hops-slider" min="1" max="3" value="2" class="mn-slider w-14" />
            <span id="mn-hops-label" class="font-mono text-[10px] text-brass/60">2</span>
          </div>
          <button id="mn-strengthen-btn" class="font-mono text-[9px] tracking-wider uppercase px-2 py-0.5 rounded-sm border border-brass/10 text-chrome-dark/30 hover:text-brass hover:border-brass/25 transition-all cursor-pointer">Strengthen</button>
          <button id="mn-reset-btn" class="font-mono text-[9px] tracking-wider uppercase px-2 py-0.5 rounded-sm border border-brass/10 text-chrome-dark/30 hover:text-brass hover:border-brass/25 transition-all cursor-pointer">Reset</button>
        </div>
      </div>

      <!-- Legend -->
      <div class="flex items-center gap-4 px-4 py-2 border-b border-brass/5 bg-steel/20">
        <div class="flex items-center gap-1.5">
          <span class="inline-block w-2.5 h-2.5 rounded-full" style="background: #c9a961; box-shadow: 0 0 6px rgba(201,169,97,0.5);"></span>
          <span class="font-mono text-[9px] text-chrome-dark/40">Direct match</span>
        </div>
        <div class="flex items-center gap-1.5">
          <span class="inline-block w-2.5 h-2.5 rounded-full" style="background: rgba(201,169,97,0.5); box-shadow: 0 0 4px rgba(201,169,97,0.3);"></span>
          <span class="font-mono text-[9px] text-chrome-dark/40">1-hop</span>
        </div>
        <div class="flex items-center gap-1.5">
          <span class="inline-block w-2.5 h-2.5 rounded-full" style="background: rgba(201,169,97,0.25);"></span>
          <span class="font-mono text-[9px] text-chrome-dark/40">2-hop</span>
        </div>
        <div class="flex items-center gap-1.5">
          <span class="inline-block w-2.5 h-2.5 rounded-full" style="background: rgba(184,184,184,0.15);"></span>
          <span class="font-mono text-[9px] text-chrome-dark/40">Inactive</span>
        </div>
        <div class="ml-auto flex items-center gap-1.5">
          <span class="inline-block w-6 h-0.5 rounded" style="background: linear-gradient(90deg, rgba(201,169,97,0.5), rgba(201,169,97,0.15));"></span>
          <span class="font-mono text-[9px] text-chrome-dark/40">Well-trodden paths glow brighter</span>
        </div>
      </div>

      <!-- Canvas -->
      <div class="relative" style="height: 460px;">
        <canvas id="mn-canvas" class="w-full h-full" style="display: block;"></canvas>
        <!-- Node detail tooltip -->
        <div id="mn-tooltip" class="mn-tooltip hidden absolute bg-steel border border-brass/20 rounded-sm p-3 z-20 pointer-events-none" style="max-width: 260px;">
          <div id="mn-tooltip-title" class="font-mono text-[11px] text-brass font-bold mb-1"></div>
          <div id="mn-tooltip-detail" class="font-serif text-[12px] text-chrome-dark/70 leading-relaxed mb-2"></div>
          <div id="mn-tooltip-connections" class="font-mono text-[9px] text-chrome-dark/40"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ToC -->
  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#do-it-with-deja" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Do it with deja</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#the-biological-parallel" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The biological parallel</a>
    <a href="#why-this-is-radical" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Why this is radical</a>
  </Fragment>

  <!-- Content -->
  <h2 id="the-experience">The experience</h2>

  <p>You are not searching. You are activating. You type "database migration" into the context field and press Activate. For a moment, nothing changes. The network floats gently on the canvas -- twenty-some nodes connected by thin lines of varying thickness, drifting with a slow, organic motion that suggests life rather than computation. Then the wave begins.</p>

  <p>Two nodes light up bright brass: "back up before migrating" and "check schema version." These are direct matches -- memories whose content is semantically close to "database migration." Their glow is warm and immediate, like embers catching fire. The connections radiating from these nodes begin to brighten.</p>

  <p>Half a second later, the activation spreads. Nodes one hop away begin to glow, dimmer but clearly lit: "schema changes," "expand-contract pattern," "API versioning." These are not about database migration specifically, but they are connected to things that are. The edges between them and the direct matches thicken slightly, pulsing with the transmission of relevance.</p>

  <p>After another half second, the second hop arrives. "Mobile app broke when API changed" lights up faintly at the periphery of the network. So does "always version external APIs" and "rollback plan for breaking changes." These nodes are two associations away from your query. No cosine similarity search would ever surface "mobile app broke when API changed" for a query about database migration. The embedding vectors are too distant. But through the network -- through the chain of migration leads to schema changes, schema changes leads to API versioning, API versioning leads to the mobile app incident -- the connection exists. The network found knowledge that keyword search, semantic search, and even sophisticated RAG pipelines would miss.</p>

  <p>You click on the "mobile app broke" node. A tooltip appears showing the full memory, its connections (three edges to other nodes), and how it was activated (2-hop path from "database migration" through "API versioning"). You drag the hops slider from 2 to 3. A third wave of even fainter activation ripples outward, touching nodes at the very edge of the network. One of them is "user communication template for breaking changes." Three hops from database migration, through API versioning, through the mobile app incident, to a communication template. A thread of association that no single agent ever explicitly drew, but that the network holds in its topology.</p>

  <p>You press the Strengthen button, then click the edge between "schema changes" and "API versioning." The line grows thicker. You are telling the network that this connection matters -- that these two memories belong together more strongly than the default. Over time, as agents recall these memories in the same contexts, the connections strengthen automatically. The thickest lines in the network are the well-trodden paths: associations that have been validated by repeated co-occurrence. They glow faintly even when inactive, a visual record of what the system has learned about how knowledge relates.</p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>The mycelial network reveals emergent knowledge -- facts that no single agent stored, but that exist in the pattern of connections between stored facts. This is the key insight, and it deserves careful examination. When Agent A stores "back up before migrating" and Agent B stores "schema changes can break API consumers" and Agent C stores "the mobile app broke when the API changed," no individual agent has encoded the full causal chain. But the network has. The path from database migration to mobile app failure exists in the connection topology, even though no node contains that information explicitly.</p>

  <p>This is a fundamentally different model of knowledge than what any other interface in this series offers. The filing cabinet treats knowledge as rows. The journal treats it as events. The constellation map treats it as points in embedding space. All of these are representations where knowledge lives in the nodes -- in the individual memories themselves. The mycelial network is the first interface where knowledge lives in the edges. The connections are not metadata about the memories; they are the knowledge itself. A single node in isolation is a fact. Two nodes connected are a relationship. A path through multiple connections is an insight that transcends any individual fact along the route.</p>

  <p>The network also reveals something about the structure of expertise. In a well-developed knowledge domain, the network is dense -- many nodes, many connections, thick edges from frequent co-recall. In an underdeveloped domain, the network is sparse, with isolated nodes that have few connections. The shape of the network is a map of organizational competence. Dense clusters are well-understood areas where agents have accumulated not just facts but relationships between facts. Sparse areas are knowledge frontiers where individual learnings exist but the relational structure has not yet formed.</p>

  <p>Perhaps most striking is what the activation wave reveals about knowledge retrieval itself. Traditional retrieval asks: "Which stored facts are similar to my query?" The network asks: "What can I reach from my query by following associations?" These are profoundly different questions. The first is bounded by the embedding space -- it can only return things that are semantically close. The second is bounded by the topology -- it can return things that are semantically distant but associatively connected. The memory about the mobile app is nowhere near "database migration" in vector space. It is two hops away in association space. The network finds it. Cosine similarity never would.</p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>Implementation requires a new data structure: a <code>memory_connections</code> table that stores weighted edges between learnings. The schema is minimal:</p>

  <pre><code set:html={`CREATE TABLE memory_connections (
  learning_id_a UUID REFERENCES learnings(id),
  learning_id_b UUID REFERENCES learnings(id),
  strength FLOAT DEFAULT 0.1,
  co_recall_count INT DEFAULT 0,
  last_co_recall TIMESTAMP,
  PRIMARY KEY (learning_id_a, learning_id_b)
);`} /></pre>

  <p>Connections form automatically. Every time an agent runs <code>/inject</code> and receives a set of memories, every pair of returned memories has their connection strength incremented. If "back up before migrating" and "check schema version" are both returned in the same injection result, the edge between them strengthens. The formula is simple: <code>strength = 1 - (1 / (1 + co_recall_count))</code>. A single co-recall gives strength 0.5. Ten co-recalls give strength 0.91. The connection asymptotically approaches 1.0 but never reaches it. This mirrors the biological principle that synaptic connections strengthen with use but never become absolute.</p>

  <p>The activation algorithm is a breadth-first graph walk with decaying activation. Starting from seed nodes (direct matches to the query), each hop multiplies the activation level by a decay factor -- say 0.5. Direct matches activate at 1.0. One-hop neighbors activate at <code>1.0 * edge_strength * 0.5</code>. Two-hop neighbors activate at the product of both edge strengths times 0.25. This means that a two-hop path through two strong connections (strength 0.9 each) produces activation <code>0.9 * 0.9 * 0.25 = 0.2</code>, while two-hop through weak connections (strength 0.2 each) produces <code>0.2 * 0.2 * 0.25 = 0.01</code> -- effectively invisible. The network self-selects for well-trodden paths.</p>

  <p>The most significant architectural change is to <code>/inject</code> itself. Today, injection returns the top-k memories by cosine similarity. With the network, injection becomes a hybrid: first, find the top-k by cosine similarity (the direct matches), then perform a graph walk from those seeds, then merge the results by combining cosine score and activation score. The graph walk is O(n) in the number of connections, which for a reasonable memory pool (hundreds to low thousands of memories) completes in single-digit milliseconds. The cost is negligible. The informational gain is substantial.</p>

  <DoItWithDeja
    blurb="List learnings, build graph from similarity (client-side) or co-recall logs. Inject for seeds; extend with graph layout."
    snippets={[
      {
        label: 'Inject + build similarity graph',
        code: `const seeds = await fetch('/inject', {
  method: 'POST', body: JSON.stringify({ context })
}).then(r => r.json());
const all = await fetch('/learnings?scope=shared').then(r => r.json());
// Build edges from similarity; run BFS for activation`,
      },
    ]}
  />

  <h2 id="design-tensions">Design tensions</h2>

  <p>The deepest tension in the mycelial network is between legibility and power. The network is the most powerful retrieval mechanism in this entire research series. It can find knowledge that no other method surfaces. But it is also the hardest to explain. When a user asks "why did this memory appear?" and the answer is "because it is two hops from your query through a chain of co-recalled memories with combined activation score 0.18," the user has not been enlightened. They have been given a math problem. The filing cabinet's answer to "why is this here?" is trivially clear: it matched your search text. The network's answer is a graph traversal.</p>

  <p>There is also a cold-start problem. Connections form from co-recall, which requires memories to be retrieved together. A new memory has no connections. It is an isolated node, invisible to the graph walk, reachable only through cosine similarity. The network is most powerful for well-established memories in mature knowledge domains -- exactly the cases where it is least needed, because those memories would likely surface through traditional search anyway. The network's unique value proposition -- finding distant, unexpected connections -- requires precisely the kind of rich connection data that takes time to accumulate.</p>

  <p>Connection strength introduces a feedback loop. Memories that are frequently co-recalled develop strong connections, which makes them more likely to be activated together in future graph walks, which further strengthens their connections. This is the network equivalent of the "rich get richer" phenomenon. Well-connected memories become more connected. Isolated memories stay isolated. Left unchecked, this produces a network where a core cluster of heavily-connected memories dominates activation, while peripheral memories -- potentially the most novel and interesting -- never participate. A dampening mechanism is needed: perhaps a connection decay over time, or an exploration bonus that occasionally activates weakly-connected nodes.</p>

  <p>The strengthen button in the demo hints at human curation of the network topology. This is powerful but dangerous. A human can reinforce connections they believe are important, overriding the statistical pattern. But human intuitions about knowledge structure can be wrong, and manual connections bypass the validation mechanism of co-recall. A manually strengthened edge says "I think these are related" rather than "these have repeatedly proven relevant in the same contexts." The epistemological difference matters.</p>

  <h2 id="the-biological-parallel">The biological parallel</h2>

  <p>The name is deliberate. Mycelial networks -- the underground fungal networks that connect trees in a forest -- are the biological system that most closely parallels what this interface attempts. In a forest, individual trees are the visible entities. But beneath the surface, mycelial threads connect their root systems, allowing nutrients, chemical signals, and even information about threats to flow between trees that have no direct contact. A tree under attack by insects can send chemical warning signals through the mycelial network to trees dozens of meters away. The knowledge is not in any single tree. It is in the network.</p>

  <p>Human neural memory works similarly. When you smell a specific perfume and recall a person, a place, and a feeling simultaneously, you are not retrieving a single record from a database. You are experiencing activation spreading through a network of associations. The perfume activates an olfactory pattern, which activates a face, which activates a location, which activates an emotional state. Each activation hop is weaker than the last, which is why the perfume brings a vivid face but only a vague mood. This is exactly the activation decay in the mycelial network demo: direct matches are bright, one-hop is dimmer, two-hop is fainter still.</p>

  <p>The parallel extends to learning. In biological neural networks, connections strengthen when neurons fire together -- the Hebbian principle, often summarized as "neurons that fire together, wire together." In the mycelial network, connections strengthen when memories are recalled together. The mechanism is identical: co-activation produces stronger association. The result is a network that encodes not just what is known, but how what is known relates to everything else that is known. The topology is the knowledge.</p>

  <p>But there is a crucial difference. Biological neural networks operate at a scale of billions of connections with millisecond timing. The mycelial network in deja operates at a scale of thousands of connections with API-call timing. This is not a limitation of the concept but of the current infrastructure. As memory pools grow and connection data accumulates over months and years of agent operation, the network becomes richer, the paths become more numerous, and the emergent knowledge becomes more surprising. The mycelial network is a long-term investment. Its value compounds.</p>

  <h2 id="why-this-is-radical">Why this is radical</h2>

  <p>Every other interface in this research series treats memories as discrete objects. The filing cabinet arranges them in rows. The journal arranges them on a timeline. The constellation map arranges them in embedding space. The confidence heatmap colors them by certainty. Even the contradiction board, which examines pairs, treats each memory as a self-contained unit with properties that can be compared. In all nineteen preceding concepts, the fundamental unit of knowledge is the individual memory.</p>

  <p>The mycelial network dissolves this assumption. Here, the fundamental unit of knowledge is the connection. A single memory node, disconnected from the network, is a datum -- useful but limited. A memory node with ten strong connections to other nodes is a concept -- rich with relational meaning. The same node, in different network positions, means different things. "Check schema version" connected primarily to deployment nodes is a deployment practice. "Check schema version" connected primarily to debugging nodes is a diagnostic step. The content is identical. The meaning is determined by context, and context is encoded in the topology.</p>

  <p>This is the endgame for memory interfaces. Not because networks are inherently superior to tables or timelines -- those have genuine utility. But because the network is the only representation that captures what we actually mean by "knowing" something. To know is not to store a fact. To know is to hold a fact in a web of relationships -- to understand when it applies, what it connects to, what follows from it, what contradicts it. The filing cabinet stores facts. The mycelial network stores understanding.</p>

  <p>The implication for deja is architectural. If the network model proves viable, it suggests that the future of agent memory is not better embeddings or larger context windows or smarter retrieval algorithms. It is richer connection data. Every co-recall is a data point about the structure of knowledge. Every strengthened edge is a piece of relational intelligence that no embedding model captures. Over time, the network becomes a second knowledge base -- not of facts, but of how facts relate. And that relational knowledge is, in the deepest sense, what intelligence is. Not what you know, but how what you know connects.</p>

  <p>We started this research series with a filing cabinet. We end it here, watching activation spread through a network of memories like signal propagating through mycelium, reaching nodes that no query could find, surfacing knowledge that no agent explicitly stored. The distance between these two interfaces is not just a design evolution. It is a philosophical shift in what we believe memory is. The filing cabinet says memory is storage. The mycelial network says memory is structure. Both are true. Only one points toward the future.</p>

</ResearchLayout>

<style>
  .mn-demo {
    overflow: hidden;
  }

  .mn-slider {
    -webkit-appearance: none;
    appearance: none;
    height: 3px;
    background: rgba(201, 169, 97, 0.15);
    border-radius: 2px;
    outline: none;
  }

  .mn-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #c9a961;
    cursor: pointer;
  }

  .mn-preset-btn {
    color: rgba(184, 184, 184, 0.35);
    background: transparent;
    border: 1px solid rgba(201, 169, 97, 0.08);
  }

  .mn-preset-btn:hover {
    color: rgba(201, 169, 97, 0.7);
    background: rgba(201, 169, 97, 0.05);
    border-color: rgba(201, 169, 97, 0.2);
  }

  .mn-tooltip {
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(8px);
  }

  #mn-canvas {
    cursor: default;
  }
</style>

<script>
  interface NetworkNode {
    id: number;
    label: string;
    detail: string;
    x: number;
    y: number;
    vx: number;
    vy: number;
    radius: number;
    activation: number;
    hopLevel: number;
    contexts: string[];
  }

  interface NetworkEdge {
    from: number;
    to: number;
    strength: number;
    baseStrength: number;
  }

  const nodeData: { label: string; detail: string; contexts: string[] }[] = [
    { label: "back up before migrating", detail: "Always create a full backup before running any database migration. Learned from a failed migration that corrupted production data.", contexts: ["database migration"] },
    { label: "check schema version", detail: "Verify the current schema version before applying migrations. Prevents applying migrations out of order.", contexts: ["database migration"] },
    { label: "expand-contract pattern", detail: "Use expand-contract for breaking schema changes. Add new columns first, migrate data, then remove old columns.", contexts: ["database migration", "API design"] },
    { label: "schema changes", detail: "Schema changes should be backward-compatible. Old code should be able to read new schema.", contexts: ["database migration"] },
    { label: "API versioning", detail: "Version all API endpoints. Never make breaking changes to an existing version.", contexts: ["API design"] },
    { label: "mobile app broke", detail: "The mobile app broke when the API changed without versioning. 2-hour outage, 4000 affected users.", contexts: ["incident response"] },
    { label: "always version external APIs", detail: "External-facing APIs must be versioned. Internal APIs can use feature flags.", contexts: ["API design"] },
    { label: "rollback plan", detail: "Every migration needs a tested rollback plan. Not just a theory -- actually run the rollback in staging.", contexts: ["database migration", "incident response"] },
    { label: "test with production data", detail: "Run migrations against a copy of production data, not just test fixtures. Size and edge cases matter.", contexts: ["database migration"] },
    { label: "zero-downtime deploys", detail: "Use blue-green or rolling deploys to achieve zero-downtime. Never take the service down for a migration.", contexts: ["database migration"] },
    { label: "migration lock timeout", detail: "Set lock_timeout on migration transactions. A blocked migration holding a lock can cascade into a full outage.", contexts: ["database migration", "incident response"] },
    { label: "notify stakeholders", detail: "Send notifications before and after major migrations. Stakeholders should know when data is being changed.", contexts: ["database migration"] },
    { label: "rate limit APIs", detail: "Implement rate limiting on all public API endpoints. Prevents abuse and cascading failures.", contexts: ["API design"] },
    { label: "circuit breakers", detail: "Use circuit breakers for inter-service calls. Fail fast rather than cascading timeouts.", contexts: ["incident response", "API design"] },
    { label: "incident postmortem", detail: "Write a blameless postmortem within 48 hours of any incident. Focus on systems, not people.", contexts: ["incident response"] },
    { label: "runbook for each service", detail: "Maintain a runbook for each service. Include common failure modes, diagnostic commands, and escalation paths.", contexts: ["incident response"] },
    { label: "user communication template", detail: "Have pre-drafted communication templates for common incident types. Speed matters when users are affected.", contexts: ["incident response"] },
    { label: "health check endpoints", detail: "Every service needs /health and /ready endpoints. Kubernetes and load balancers depend on them.", contexts: ["API design", "incident response"] },
    { label: "idempotent operations", detail: "All write operations should be idempotent. Retries should be safe. Use idempotency keys.", contexts: ["API design", "database migration"] },
    { label: "feature flags for rollout", detail: "Use feature flags to gradually roll out changes. Start at 5%, monitor, then increase.", contexts: ["API design"] },
    { label: "monitor error rates", detail: "Set alerts on error rate thresholds. A 1% increase in 500s should page someone.", contexts: ["incident response"] },
    { label: "dependency audit", detail: "Audit dependencies quarterly. Known vulnerabilities in transitive dependencies cause most security incidents.", contexts: ["API design", "incident response"] },
    { label: "cache invalidation plan", detail: "Document how and when each cache is invalidated. Stale caches are the silent cause of most 'weird' bugs.", contexts: ["API design", "database migration"] },
  ];

  const edgeDefs: [number, number, number][] = [
    [0, 1, 0.9],   // back up <-> check schema
    [0, 3, 0.7],   // back up <-> schema changes
    [1, 3, 0.8],   // check schema <-> schema changes
    [3, 2, 0.75],  // schema changes <-> expand-contract
    [3, 4, 0.65],  // schema changes <-> API versioning
    [4, 5, 0.7],   // API versioning <-> mobile app broke
    [4, 6, 0.85],  // API versioning <-> always version external
    [5, 6, 0.6],   // mobile app broke <-> always version
    [5, 16, 0.55], // mobile app broke <-> user communication
    [5, 14, 0.5],  // mobile app broke <-> postmortem
    [0, 7, 0.7],   // back up <-> rollback plan
    [7, 8, 0.6],   // rollback plan <-> test with prod data
    [0, 8, 0.5],   // back up <-> test with prod data
    [9, 2, 0.55],  // zero-downtime <-> expand-contract
    [9, 0, 0.45],  // zero-downtime <-> back up
    [10, 7, 0.6],  // migration lock <-> rollback plan
    [10, 0, 0.5],  // migration lock <-> back up
    [11, 0, 0.4],  // notify <-> back up
    [11, 16, 0.45],// notify <-> user communication
    [12, 4, 0.5],  // rate limit <-> API versioning
    [12, 13, 0.6], // rate limit <-> circuit breakers
    [13, 15, 0.55],// circuit breakers <-> runbook
    [13, 17, 0.65],// circuit breakers <-> health check
    [14, 15, 0.7], // postmortem <-> runbook
    [14, 16, 0.6], // postmortem <-> user communication
    [14, 20, 0.55],// postmortem <-> monitor errors
    [15, 17, 0.5], // runbook <-> health check
    [17, 13, 0.6], // health check <-> circuit breakers (already defined above as 13,17)
    [18, 2, 0.5],  // idempotent <-> expand-contract
    [18, 4, 0.45], // idempotent <-> API versioning
    [19, 4, 0.55], // feature flags <-> API versioning
    [19, 9, 0.4],  // feature flags <-> zero-downtime
    [20, 17, 0.6], // monitor errors <-> health check
    [20, 15, 0.55],// monitor errors <-> runbook
    [21, 12, 0.4], // dependency audit <-> rate limit
    [21, 13, 0.35],// dependency audit <-> circuit breakers
    [22, 3, 0.45], // cache invalidation <-> schema changes
    [22, 18, 0.4], // cache invalidation <-> idempotent
    [6, 19, 0.4],  // always version <-> feature flags
    [7, 10, 0.55], // rollback plan <-> migration lock
    [16, 20, 0.45],// user communication <-> monitor errors
  ];

  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let nodes: NetworkNode[] = [];
  let edges: NetworkEdge[] = [];
  let maxHops = 2;
  let animFrame: number;
  let hoveredNode: NetworkNode | null = null;
  let selectedEdge: NetworkEdge | null = null;
  let strengthenMode = false;
  let isActivating = false;

  function initNetwork() {
    canvas = document.getElementById('mn-canvas') as HTMLCanvasElement;
    ctx = canvas.getContext('2d')!;

    const rect = canvas.parentElement!.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    const w = rect.width;
    const h = rect.height;

    // Position nodes in organic clusters
    const centerX = w / 2;
    const centerY = h / 2;

    nodes = nodeData.map((nd, i) => {
      // Arrange in a rough ellipse with jitter, grouped by context
      const angle = (i / nodeData.length) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
      const radiusX = w * 0.32 + (Math.random() - 0.5) * w * 0.12;
      const radiusY = h * 0.34 + (Math.random() - 0.5) * h * 0.1;

      return {
        id: i,
        label: nd.label,
        detail: nd.detail,
        x: centerX + Math.cos(angle) * radiusX,
        y: centerY + Math.sin(angle) * radiusY,
        vx: (Math.random() - 0.5) * 0.08,
        vy: (Math.random() - 0.5) * 0.08,
        radius: 5,
        activation: 0,
        hopLevel: -1,
        contexts: nd.contexts,
      };
    });

    // Deduplicate edges
    const edgeSet = new Set<string>();
    edges = [];
    edgeDefs.forEach(([from, to, strength]) => {
      const key = from < to ? `${from}-${to}` : `${to}-${from}`;
      if (!edgeSet.has(key)) {
        edgeSet.add(key);
        edges.push({ from, to, strength, baseStrength: strength });
      }
    });

    // Run a few force-directed iterations to spread nodes
    for (let iter = 0; iter < 80; iter++) {
      forceStep(w, h);
    }
    // Zero velocities after initial layout
    nodes.forEach(n => { n.vx = (Math.random() - 0.5) * 0.06; n.vy = (Math.random() - 0.5) * 0.06; });
  }

  function forceStep(w: number, h: number) {
    const repulsion = 2000;
    const attraction = 0.005;
    const centerPull = 0.002;

    // Repulsion between all pairs
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = repulsion / (dist * dist);
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        nodes[i].vx += fx;
        nodes[i].vy += fy;
        nodes[j].vx -= fx;
        nodes[j].vy -= fy;
      }
    }

    // Attraction along edges
    edges.forEach(e => {
      const a = nodes[e.from];
      const b = nodes[e.to];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const force = dist * attraction * e.strength;
      a.vx += (dx / dist) * force;
      a.vy += (dy / dist) * force;
      b.vx -= (dx / dist) * force;
      b.vy -= (dy / dist) * force;
    });

    // Center pull
    const cx = w / 2;
    const cy = h / 2;
    nodes.forEach(n => {
      n.vx += (cx - n.x) * centerPull;
      n.vy += (cy - n.y) * centerPull;
    });

    // Apply velocity with damping
    nodes.forEach(n => {
      n.vx *= 0.85;
      n.vy *= 0.85;
      n.x += n.vx;
      n.y += n.vy;
      // Keep in bounds
      n.x = Math.max(50, Math.min(w - 50, n.x));
      n.y = Math.max(30, Math.min(h - 30, n.y));
    });
  }

  function activate(context: string) {
    if (isActivating) return;
    isActivating = true;

    // Reset all activation
    nodes.forEach(n => { n.activation = 0; n.hopLevel = -1; });

    const contextLower = context.toLowerCase();

    // Find direct matches
    const directMatches: number[] = [];
    nodes.forEach(n => {
      const matchesContext = n.contexts.some(c => c.toLowerCase().includes(contextLower) || contextLower.includes(c.toLowerCase()));
      const matchesLabel = n.label.toLowerCase().includes(contextLower) || contextLower.split(' ').some(word => n.label.toLowerCase().includes(word));
      if (matchesContext || matchesLabel) {
        directMatches.push(n.id);
      }
    });

    // If no matches, try fuzzy matching on individual words
    if (directMatches.length === 0) {
      const words = contextLower.split(/\s+/);
      nodes.forEach(n => {
        if (words.some(w => w.length > 3 && n.label.toLowerCase().includes(w))) {
          directMatches.push(n.id);
        }
      });
    }

    // Activate direct matches immediately
    directMatches.forEach(id => {
      nodes[id].activation = 1.0;
      nodes[id].hopLevel = 0;
    });

    // 1-hop after 500ms
    setTimeout(() => {
      if (maxHops >= 1) {
        const hop1: Set<number> = new Set();
        directMatches.forEach(id => {
          edges.forEach(e => {
            if (e.from === id && nodes[e.to].hopLevel === -1) {
              const act = 1.0 * e.strength * 0.5;
              if (act > nodes[e.to].activation) {
                nodes[e.to].activation = act;
                nodes[e.to].hopLevel = 1;
                hop1.add(e.to);
              }
            }
            if (e.to === id && nodes[e.from].hopLevel === -1) {
              const act = 1.0 * e.strength * 0.5;
              if (act > nodes[e.from].activation) {
                nodes[e.from].activation = act;
                nodes[e.from].hopLevel = 1;
                hop1.add(e.from);
              }
            }
          });
        });

        // 2-hop after 1000ms
        setTimeout(() => {
          if (maxHops >= 2) {
            const hop1Arr = Array.from(hop1);
            const hop2: Set<number> = new Set();
            hop1Arr.forEach(id => {
              edges.forEach(e => {
                if (e.from === id && nodes[e.to].hopLevel === -1) {
                  const parentAct = nodes[id].activation;
                  const act = parentAct * e.strength * 0.5;
                  if (act > nodes[e.to].activation) {
                    nodes[e.to].activation = act;
                    nodes[e.to].hopLevel = 2;
                    hop2.add(e.to);
                  }
                }
                if (e.to === id && nodes[e.from].hopLevel === -1) {
                  const parentAct = nodes[id].activation;
                  const act = parentAct * e.strength * 0.5;
                  if (act > nodes[e.from].activation) {
                    nodes[e.from].activation = act;
                    nodes[e.from].hopLevel = 2;
                    hop2.add(e.from);
                  }
                }
              });
            });

            // 3-hop after 1500ms
            setTimeout(() => {
              if (maxHops >= 3) {
                const hop2Arr = Array.from(hop2);
                hop2Arr.forEach(id => {
                  edges.forEach(e => {
                    if (e.from === id && nodes[e.to].hopLevel === -1) {
                      const parentAct = nodes[id].activation;
                      const act = parentAct * e.strength * 0.5;
                      if (act > 0.01) {
                        nodes[e.to].activation = Math.max(nodes[e.to].activation, act);
                        nodes[e.to].hopLevel = 3;
                      }
                    }
                    if (e.to === id && nodes[e.from].hopLevel === -1) {
                      const parentAct = nodes[id].activation;
                      const act = parentAct * e.strength * 0.5;
                      if (act > 0.01) {
                        nodes[e.from].activation = Math.max(nodes[e.from].activation, act);
                        nodes[e.from].hopLevel = 3;
                      }
                    }
                  });
                });
              }
              isActivating = false;
            }, 500);
          } else {
            isActivating = false;
          }
        }, 500);
      } else {
        isActivating = false;
      }
    }, 500);
  }

  function draw() {
    const rect = canvas.parentElement!.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0, 0, w, h);

    // Gentle drift
    nodes.forEach(n => {
      n.x += n.vx;
      n.y += n.vy;

      // Soft bounce
      if (n.x < 50 || n.x > w - 50) n.vx *= -0.8;
      if (n.y < 30 || n.y > h - 30) n.vy *= -0.8;
      n.x = Math.max(50, Math.min(w - 50, n.x));
      n.y = Math.max(30, Math.min(h - 30, n.y));

      // Tiny random nudge for organic feel
      n.vx += (Math.random() - 0.5) * 0.003;
      n.vy += (Math.random() - 0.5) * 0.003;
      n.vx *= 0.998;
      n.vy *= 0.998;
    });

    // Draw edges
    edges.forEach(e => {
      const a = nodes[e.from];
      const b = nodes[e.to];

      const bothActive = a.activation > 0 && b.activation > 0;
      const minActivation = Math.min(a.activation, b.activation);

      let alpha: number;
      let lineWidth: number;
      let color: string;

      if (bothActive && minActivation > 0.01) {
        alpha = 0.15 + minActivation * 0.6;
        lineWidth = 0.5 + e.strength * 2.5 + minActivation * 1.5;
        color = `rgba(201, 169, 97, ${alpha})`;

        // Glow for well-trodden paths
        if (e.strength > 0.7) {
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.strokeStyle = `rgba(201, 169, 97, ${alpha * 0.3})`;
          ctx.lineWidth = lineWidth + 3;
          ctx.stroke();
        }
      } else {
        alpha = 0.04 + e.strength * 0.06;
        lineWidth = 0.3 + e.strength * 0.8;
        color = `rgba(184, 184, 184, ${alpha})`;

        // Subtle glow for strong inactive edges (well-trodden paths)
        if (e.strength > 0.75) {
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.strokeStyle = `rgba(201, 169, 97, 0.03)`;
          ctx.lineWidth = lineWidth + 2;
          ctx.stroke();
        }
      }

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    });

    // Draw nodes
    nodes.forEach(n => {
      const isHovered = hoveredNode && hoveredNode.id === n.id;
      let fillColor: string;
      let glowColor: string;
      let r = n.radius;

      if (n.activation > 0) {
        if (n.hopLevel === 0) {
          fillColor = '#c9a961';
          glowColor = 'rgba(201, 169, 97, 0.6)';
          r = 7;
        } else if (n.hopLevel === 1) {
          fillColor = `rgba(201, 169, 97, ${0.4 + n.activation * 0.4})`;
          glowColor = `rgba(201, 169, 97, ${0.2 + n.activation * 0.2})`;
          r = 6;
        } else if (n.hopLevel === 2) {
          fillColor = `rgba(201, 169, 97, ${0.15 + n.activation * 0.3})`;
          glowColor = `rgba(201, 169, 97, ${n.activation * 0.15})`;
          r = 5.5;
        } else {
          fillColor = `rgba(201, 169, 97, ${0.1 + n.activation * 0.2})`;
          glowColor = `rgba(201, 169, 97, ${n.activation * 0.08})`;
          r = 5;
        }
      } else {
        fillColor = 'rgba(184, 184, 184, 0.15)';
        glowColor = 'transparent';
        r = 4.5;
      }

      if (isHovered) r += 2;

      // Glow
      if (n.activation > 0 || isHovered) {
        ctx.beginPath();
        ctx.arc(n.x, n.y, r + 6, 0, Math.PI * 2);
        ctx.fillStyle = isHovered ? 'rgba(201, 169, 97, 0.15)' : glowColor;
        ctx.fill();
      }

      // Node circle
      ctx.beginPath();
      ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
      ctx.fillStyle = fillColor;
      ctx.fill();

      // Border
      if (n.activation > 0) {
        ctx.strokeStyle = `rgba(201, 169, 97, ${0.3 + n.activation * 0.4})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Label
      const labelAlpha = n.activation > 0 ? 0.5 + n.activation * 0.5 : (isHovered ? 0.7 : 0.2);
      ctx.font = `${isHovered ? 11 : 9}px var(--font-mono), monospace`;
      ctx.fillStyle = n.activation > 0
        ? `rgba(201, 169, 97, ${labelAlpha})`
        : `rgba(184, 184, 184, ${labelAlpha})`;
      ctx.textAlign = 'center';
      ctx.fillText(n.label, n.x, n.y + r + 13);
    });

    animFrame = requestAnimationFrame(draw);
  }

  function getNodeAt(mx: number, my: number): NetworkNode | null {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i];
      const dx = mx - n.x;
      const dy = my - n.y;
      if (dx * dx + dy * dy < 225) return n; // ~15px radius for click target
    }
    return null;
  }

  function getEdgeAt(mx: number, my: number): NetworkEdge | null {
    for (const e of edges) {
      const a = nodes[e.from];
      const b = nodes[e.to];
      // Point-to-segment distance
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len2 = dx * dx + dy * dy;
      if (len2 === 0) continue;
      let t = ((mx - a.x) * dx + (my - a.y) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const px = a.x + t * dx;
      const py = a.y + t * dy;
      const dist = Math.sqrt((mx - px) * (mx - px) + (my - py) * (my - py));
      if (dist < 8) return e;
    }
    return null;
  }

  // Initialize
  initNetwork();
  draw();

  // Activate on button click
  document.getElementById('mn-activate-btn')!.addEventListener('click', () => {
    const input = document.getElementById('mn-context-input') as HTMLInputElement;
    activate(input.value);
  });

  // Enter key on input
  document.getElementById('mn-context-input')!.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      activate((e.target as HTMLInputElement).value);
    }
  });

  // Preset buttons
  document.querySelectorAll('.mn-preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const context = (btn as HTMLElement).dataset.context!;
      (document.getElementById('mn-context-input') as HTMLInputElement).value = context;
      activate(context);
    });
  });

  // Hops slider
  document.getElementById('mn-hops-slider')!.addEventListener('input', (e) => {
    maxHops = parseInt((e.target as HTMLInputElement).value);
    document.getElementById('mn-hops-label')!.textContent = String(maxHops);
  });

  // Strengthen button
  document.getElementById('mn-strengthen-btn')!.addEventListener('click', () => {
    strengthenMode = !strengthenMode;
    const btn = document.getElementById('mn-strengthen-btn')!;
    if (strengthenMode) {
      btn.style.color = '#c9a961';
      btn.style.borderColor = 'rgba(201, 169, 97, 0.4)';
      btn.style.background = 'rgba(201, 169, 97, 0.1)';
      canvas.style.cursor = 'crosshair';
    } else {
      btn.style.color = '';
      btn.style.borderColor = '';
      btn.style.background = '';
      canvas.style.cursor = 'default';
    }
  });

  // Reset button
  document.getElementById('mn-reset-btn')!.addEventListener('click', () => {
    nodes.forEach(n => { n.activation = 0; n.hopLevel = -1; });
    edges.forEach(e => { e.strength = e.baseStrength; });
    isActivating = false;
  });

  // Canvas mouse events
  const tooltip = document.getElementById('mn-tooltip')!;
  const tooltipTitle = document.getElementById('mn-tooltip-title')!;
  const tooltipDetail = document.getElementById('mn-tooltip-detail')!;
  const tooltipConnections = document.getElementById('mn-tooltip-connections')!;

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    hoveredNode = getNodeAt(mx, my);

    if (hoveredNode) {
      canvas.style.cursor = strengthenMode ? 'crosshair' : 'pointer';
      const connectedEdges = edges.filter(ed => ed.from === hoveredNode!.id || ed.to === hoveredNode!.id);
      const connectedNames = connectedEdges.map(ed => {
        const otherId = ed.from === hoveredNode!.id ? ed.to : ed.from;
        return `${nodes[otherId].label} (${ed.strength.toFixed(2)})`;
      });

      tooltipTitle.textContent = hoveredNode.label;
      tooltipDetail.textContent = hoveredNode.detail;
      tooltipConnections.textContent = `${connectedEdges.length} connections: ${connectedNames.join(', ')}`;

      // Position tooltip
      let tx = mx + 16;
      let ty = my - 10;
      const parentRect = canvas.parentElement!.getBoundingClientRect();
      if (tx + 260 > parentRect.width) tx = mx - 270;
      if (ty + 120 > parentRect.height) ty = my - 120;

      tooltip.style.left = `${tx}px`;
      tooltip.style.top = `${ty}px`;
      tooltip.classList.remove('hidden');
    } else {
      canvas.style.cursor = strengthenMode ? 'crosshair' : 'default';
      tooltip.classList.add('hidden');
    }
  });

  canvas.addEventListener('click', (e) => {
    if (!strengthenMode) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const edge = getEdgeAt(mx, my);
    if (edge) {
      edge.strength = Math.min(1.0, edge.strength + 0.1);
    }
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredNode = null;
    tooltip.classList.add('hidden');
  });

  // Handle resize
  window.addEventListener('resize', () => {
    const rect = canvas.parentElement!.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  });
</script>
