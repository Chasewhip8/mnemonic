---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('confidence-heatmap')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="demo-container bg-void-deep border border-brass/10 rounded-sm p-6 md:p-8">
      <div class="flex items-center justify-between mb-6">
        <div>
          <h3 class="font-serif-sc text-lg font-bold m-0 text-chrome">Confidence Heatmap</h3>
          <p class="font-mono text-[11px] text-chrome-dark/50 m-0 mt-1">deploy-bot — last 7 months — 5 topic clusters</p>
        </div>
        <div class="font-mono text-[10px] text-chrome-dark/40">hover to inspect</div>
      </div>

      <!-- Legend -->
      <div class="flex items-center gap-4 mb-6 flex-wrap">
        <span class="font-mono text-[10px] text-chrome-dark/50 uppercase tracking-widest">Confidence:</span>
        <div class="flex items-center gap-1.5">
          <div class="w-3 h-3 rounded-sm legend-high"></div>
          <span class="font-mono text-[10px] text-chrome-dark/50">High (0.8-1.0)</span>
        </div>
        <div class="flex items-center gap-1.5">
          <div class="w-3 h-3 rounded-sm legend-medium"></div>
          <span class="font-mono text-[10px] text-chrome-dark/50">Medium (0.5-0.7)</span>
        </div>
        <div class="flex items-center gap-1.5">
          <div class="w-3 h-3 rounded-sm legend-low"></div>
          <span class="font-mono text-[10px] text-chrome-dark/50">Low (0.3-0.5)</span>
        </div>
        <div class="flex items-center gap-1.5">
          <div class="w-3 h-3 rounded-sm legend-critical"></div>
          <span class="font-mono text-[10px] text-chrome-dark/50">Critical (&lt;0.3)</span>
        </div>
        <div class="flex items-center gap-1.5">
          <div class="w-3 h-3 rounded-sm legend-empty"></div>
          <span class="font-mono text-[10px] text-chrome-dark/50">No data</span>
        </div>
      </div>

      <!-- Heatmap grid -->
      <div class="heatmap-grid" id="heatmap">
        <!-- Y-axis labels -->
        <div class="heatmap-label-corner"></div>
        <div class="heatmap-col-label font-mono text-[10px] text-chrome-dark/50">Deployment</div>
        <div class="heatmap-col-label font-mono text-[10px] text-chrome-dark/50">Testing</div>
        <div class="heatmap-col-label font-mono text-[10px] text-chrome-dark/50">Database</div>
        <div class="heatmap-col-label font-mono text-[10px] text-chrome-dark/50">Monitoring</div>
        <div class="heatmap-col-label font-mono text-[10px] text-chrome-dark/50">Security</div>
        <!-- Rows will be injected by JS -->
      </div>

      <!-- Tooltip -->
      <div id="heatmap-tooltip" class="heatmap-tooltip hidden">
        <div class="font-mono text-[10px] text-brass mb-1" id="tooltip-trigger"></div>
        <div class="font-mono text-[10px] text-chrome-dark/70" id="tooltip-confidence"></div>
        <div class="font-mono text-[10px] text-chrome-dark/50" id="tooltip-recalled"></div>
      </div>

      <!-- Detail panel for dim region click -->
      <div id="heatmap-detail" class="hidden mt-4 p-4 bg-steel border border-brass/10 rounded-sm">
        <div class="font-mono text-[11px] text-brass mb-1" id="detail-title"></div>
        <div class="font-serif text-[13px] text-chrome-dark/70" id="detail-body"></div>
      </div>

      <!-- Summary -->
      <div class="mt-6 p-4 bg-steel/50 border border-brass/10 rounded-sm">
        <div class="font-mono text-[10px] text-brass uppercase tracking-widest mb-2">Analysis</div>
        <p class="font-serif text-[13px] text-chrome-dark/80 m-0">
          2 blind spots detected: <strong class="text-chrome">Monitoring</strong> (weak coverage, declining confidence) and <strong class="text-chrome">Security</strong> (no coverage in recent months). Deployment knowledge is strong and reinforced regularly.
        </p>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>

  <p>You open the heatmap and the shape is immediately legible. A grid of colored cells, topic on one axis and time on the other. Bright gold means the agent knows something well and has reinforced it recently. Dim amber means the confidence is moderate -- the learning exists but hasn't been recalled or validated in a while. Dark red means something was once learned but is now barely trusted. And the dark gaps -- those empty cells where no color exists at all -- those are the blind spots.</p>

  <p>The eye is drawn to patterns before numbers. You notice that the Deployment column glows warmly from top to bottom: this is well-trodden ground. The agent deploys frequently, encounters the same edge cases, and reinforces what it knows. Each recall strengthens the confidence score. The column is a record of repetition becoming competence.</p>

  <p>Then your eye drifts right, to Monitoring. A few dim cells, mostly in the older rows. One low-confidence entry from four months ago. Nothing recent. The agent has opinions about monitoring, technically speaking -- there are embeddings stored, triggers indexed -- but those opinions are stale and weakly held. If the agent were asked to configure alerting tomorrow, it would operate from shaky ground.</p>

  <p>Security is worse. The rightmost column is almost entirely dark. Two entries exist from six months ago, both below 0.3 confidence. They were stored once and never recalled. The agent has effectively forgotten them, even though the data persists. This is not a storage failure. It is an attention failure. The memories exist. They are just not alive.</p>

  <p>You click on the dim region in Monitoring. A detail panel expands: "3 learnings, all below 0.5 confidence, never recalled." Three things the agent was told or discovered, sitting in memory untouched. Not wrong, exactly. Just orphaned. The heatmap has turned a vague feeling -- "I think our monitoring setup might be weak" -- into a specific, visual, actionable diagnosis.</p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>The confidence heatmap reveals what we might call <strong>knowledge topology</strong>: the spatial distribution of how much an agent knows and how well it knows it. This is distinct from a simple list of memories or a search result. A list tells you what exists. The heatmap tells you what the overall shape looks like.</p>

  <p>There is a well-established principle in cartography: the most important thing a map shows you is what is absent. Empty space on a map is not nothing -- it is a deliberate statement about what has not been explored. The same principle applies here. The heatmap's empty cells and dim regions are its most valuable output. They are the questions no one has asked, the lessons no one has reinforced, the categories the agent has never encountered.</p>

  <p>The time axis adds a second dimension of insight. Confidence is not static. A learning that scored 0.9 three months ago but has not been recalled since is different from one that scored 0.9 yesterday. The heatmap makes temporal decay visible without requiring the viewer to parse timestamps. You simply look at whether the bright cells are recent or old. Old brightness is a flag: this was once important but may now be outdated.</p>

  <p>Topic clustering adds the third dimension. By arranging memories into semantic clusters -- derived from embedding similarity, not manual tagging -- the heatmap reveals organizational patterns that no individual memory can show. It answers questions like: "What does the agent spend most of its attention on?" and "Are there domains where the agent is confident but rarely active?"</p>

  <p>This last case is particularly interesting. High confidence in a rarely-used domain might mean the knowledge is solid and stable. Or it might mean the confidence score is artificially preserved because no new information has challenged it. The heatmap cannot resolve this ambiguity on its own, but it makes the ambiguity visible, which is the necessary first step.</p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>The confidence heatmap is a pure visualization layer over existing deja primitives. No new API endpoints are required. The data is already there.</p>

  <p>Confidence is a first-class field in every deja memory. Every call to <code>/learn</code> stores a confidence value between 0 and 1. Every recall via <code>/inject</code> returns memories with their confidence scores. The heatmap reads these values directly and maps them to color intensity. High confidence maps to bright brass. Low confidence maps to dim red. The visualization is a straightforward transformation of data that already exists in every memory record.</p>

  <p>Topic clusters come from the embedding space. When memories are stored, deja generates vector embeddings that capture semantic content. Memories about deployment cluster together in embedding space. Memories about database migrations cluster separately. A simple k-means or DBSCAN pass over the embedding vectors produces the topic columns. The cluster labels -- "Deployment," "Testing," "Database" -- can be derived from the most frequent terms in each cluster or assigned manually. Either way, the clustering itself is an emergent property of the embeddings deja already computes.</p>

  <p>The time axis comes from <code>created_at</code> and <code>last_recalled_at</code> timestamps. Every memory has a creation time. Grouping by month or week produces the rows. The <code>last_recalled_at</code> field, updated every time a memory is returned by <code>/inject</code>, provides the "last recalled" metadata shown in the tooltip. This is data deja tracks for its own internal confidence adjustments -- the heatmap simply surfaces it visually.</p>

  <p>The "blind spots" analysis shown in the summary requires slightly more logic: scan for topic clusters with consistently low confidence or no recent entries, then generate a natural language summary. This could be done client-side or as a lightweight analysis endpoint. But the underlying data -- confidence scores, topic clusters, and timestamps -- is all available through the existing <code>/recall</code> and <code>/state</code> endpoints.</p>

  <h2 id="design-tensions">Design tensions</h2>

  <p>The confidence heatmap is the health check that a team lead wants before shipping. "Are we confident about the things that matter?" It is the pre-flight checklist for autonomous agents, rendered as a single visual artifact.</p>

  <p>But this introduces a design tension around <strong>what counts as a topic</strong>. Embedding clusters are emergent and somewhat arbitrary. The boundary between "Deployment" and "Infrastructure" is fuzzy. Two memories that a human would group together might end up in different clusters based on the specific vocabulary used in their trigger text. The heatmap suggests clean categorical boundaries that do not actually exist in embedding space. This is a useful fiction -- all categorization is -- but it means the heatmap is an interpretation, not a measurement.</p>

  <p>There is also a tension around <strong>confidence calibration</strong>. A confidence score of 0.8 means different things in different contexts. For a deployment procedure, 0.8 might be dangerously uncertain. For a general best practice, 0.8 might be plenty. The heatmap shows all confidence values on the same color scale, which implies equivalence. A more nuanced version might allow different confidence thresholds per topic, but this adds complexity that undermines the heatmap's primary virtue: simplicity.</p>

  <p>There is also the question of <strong>what action the heatmap should trigger</strong>. Identifying a blind spot is valuable, but the heatmap does not tell you what to do about it. Should the agent be directed to learn about Monitoring? Should a human write memories manually? Should the team accept that Monitoring knowledge is weak and plan accordingly? The heatmap is diagnostic, not prescriptive. This is probably correct -- diagnosis and prescription are different responsibilities -- but it means the heatmap is most useful when embedded in a larger workflow that includes remediation paths.</p>

  <p>Finally, there is a question of <strong>scale</strong>. Five topics and seven time periods produces a legible 5x7 grid. But a real agent might have thirty topic clusters and two years of history. At that scale, the heatmap becomes a dense field of color that is harder to parse than a sorted list. The design needs to degrade gracefully: perhaps by allowing drill-down into sub-topics, or by defaulting to a high-level summary with expandable detail. The principle remains the same -- color encodes confidence, position encodes context -- but the implementation must adapt to the volume of memory it represents.</p>

  <p>Despite these tensions, the core value proposition holds: you can look at one image and understand the shape of what an agent knows. That is not something a table or a search box can provide. The heatmap occupies a specific niche in the memory interface landscape -- the synoptic view, the satellite photo, the at-a-glance health check. Every system that accumulates knowledge needs something like this. The only question is how much fidelity you sacrifice for legibility.</p>
</ResearchLayout>

<style>
  .demo-container {
    position: relative;
  }

  .heatmap-grid {
    display: grid;
    grid-template-columns: 80px repeat(5, 1fr);
    gap: 3px;
  }

  .heatmap-label-corner {
    /* empty corner cell */
  }

  .heatmap-col-label {
    text-align: center;
    padding-bottom: 8px;
  }

  .heatmap-row-label {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 8px;
    font-family: var(--font-family-mono);
    font-size: 10px;
    color: rgba(184, 184, 184, 0.5);
  }

  .heatmap-cell {
    aspect-ratio: 1;
    border-radius: 2px;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
    position: relative;
    min-height: 36px;
  }

  .heatmap-cell:hover {
    transform: scale(1.08);
    z-index: 10;
  }

  .heatmap-cell.cell-high {
    background: #c9a961;
    box-shadow: 0 0 0 1px rgba(201, 169, 97, 0.3);
  }
  .heatmap-cell.cell-high:hover {
    box-shadow: 0 0 12px rgba(201, 169, 97, 0.5);
    animation: cell-pulse-high 1.5s ease-in-out infinite;
  }

  .heatmap-cell.cell-medium {
    background: #9b7e3c;
    box-shadow: 0 0 0 1px rgba(155, 126, 60, 0.2);
  }
  .heatmap-cell.cell-medium:hover {
    box-shadow: 0 0 10px rgba(155, 126, 60, 0.4);
    animation: cell-pulse-medium 1.5s ease-in-out infinite;
  }

  .heatmap-cell.cell-low {
    background: #6b4c1a;
    box-shadow: 0 0 0 1px rgba(107, 76, 26, 0.2);
  }
  .heatmap-cell.cell-low:hover {
    box-shadow: 0 0 8px rgba(107, 76, 26, 0.4);
    animation: cell-pulse-low 1.5s ease-in-out infinite;
  }

  .heatmap-cell.cell-critical {
    background: #4a1a1a;
    box-shadow: 0 0 0 1px rgba(74, 26, 26, 0.2);
  }
  .heatmap-cell.cell-critical:hover {
    box-shadow: 0 0 8px rgba(120, 30, 30, 0.4);
    animation: cell-pulse-critical 1.5s ease-in-out infinite;
  }

  .heatmap-cell.cell-empty {
    background: #141414;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.03);
  }

  .heatmap-cell.cell-selected {
    outline: 2px solid #c9a961;
    outline-offset: 2px;
  }

  .legend-high { background: #c9a961; }
  .legend-medium { background: #9b7e3c; }
  .legend-low { background: #6b4c1a; }
  .legend-critical { background: #4a1a1a; }
  .legend-empty { background: #141414; border: 1px solid rgba(255,255,255,0.05); }

  .heatmap-tooltip {
    position: absolute;
    background: #1a1a1a;
    border: 1px solid rgba(201, 169, 97, 0.2);
    border-radius: 2px;
    padding: 8px 12px;
    pointer-events: none;
    z-index: 50;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
    max-width: 280px;
  }

  @keyframes cell-pulse-high {
    0%, 100% { box-shadow: 0 0 12px rgba(201, 169, 97, 0.5); }
    50% { box-shadow: 0 0 20px rgba(201, 169, 97, 0.7); }
  }

  @keyframes cell-pulse-medium {
    0%, 100% { box-shadow: 0 0 10px rgba(155, 126, 60, 0.4); }
    50% { box-shadow: 0 0 16px rgba(155, 126, 60, 0.6); }
  }

  @keyframes cell-pulse-low {
    0%, 100% { box-shadow: 0 0 8px rgba(107, 76, 26, 0.4); }
    50% { box-shadow: 0 0 14px rgba(107, 76, 26, 0.6); }
  }

  @keyframes cell-pulse-critical {
    0%, 100% { box-shadow: 0 0 8px rgba(120, 30, 30, 0.4); }
    50% { box-shadow: 0 0 14px rgba(120, 30, 30, 0.6); }
  }
</style>

<script>
  const heatmapData = {
    topics: ['Deployment', 'Testing', 'Database', 'Monitoring', 'Security'],
    periods: ['6mo ago', '5mo ago', '4mo ago', '3mo ago', '2mo ago', '1mo ago', 'Current'],
    cells: [
      // [topic][period] = { confidence, trigger, recalled }
      // Deployment: mostly high
      [
        { confidence: 0.7, trigger: 'Blue-green deploy pattern', recalled: '5mo ago' },
        { confidence: 0.85, trigger: 'Rollback on health check fail', recalled: '4mo ago' },
        { confidence: 0.8, trigger: 'Use deploy locks in prod', recalled: '3mo ago' },
        { confidence: 0.92, trigger: 'Canary with 5% traffic first', recalled: '2mo ago' },
        { confidence: 0.88, trigger: 'Check migration state pre-deploy', recalled: '1mo ago' },
        { confidence: 0.95, trigger: 'Always verify SSL post-deploy', recalled: 'Today' },
        { confidence: 0.91, trigger: 'Port 8080 conflict resolution', recalled: 'Today' },
      ],
      // Testing: moderate
      [
        { confidence: 0.6, trigger: 'Integration tests catch auth bugs', recalled: '4mo ago' },
        { confidence: 0.55, trigger: 'Mock external APIs in staging', recalled: '3mo ago' },
        { confidence: 0.8, trigger: 'Smoke test after every deploy', recalled: '2mo ago' },
        { confidence: 0.45, trigger: 'Load test before major releases', recalled: '4mo ago' },
        { confidence: 0.75, trigger: 'Contract tests for microservices', recalled: '1mo ago' },
        { confidence: 0.7, trigger: 'Snapshot tests for UI components', recalled: '2mo ago' },
        { confidence: null, trigger: null, recalled: null },
      ],
      // Database: mixed
      [
        { confidence: 0.9, trigger: 'Never run migrations without backup', recalled: '2mo ago' },
        { confidence: null, trigger: null, recalled: null },
        { confidence: 0.65, trigger: 'Index scans over table scans', recalled: '3mo ago' },
        { confidence: 0.82, trigger: 'Connection pool max 20 in prod', recalled: '1mo ago' },
        { confidence: null, trigger: null, recalled: null },
        { confidence: 0.78, trigger: 'Use read replicas for reports', recalled: '1mo ago' },
        { confidence: 0.85, trigger: 'Schema changes need review', recalled: 'Today' },
      ],
      // Monitoring: mostly dim/weak
      [
        { confidence: 0.4, trigger: 'Alert on 5xx spike > 1%', recalled: 'Never' },
        { confidence: 0.35, trigger: 'Dashboard for latency p99', recalled: 'Never' },
        { confidence: null, trigger: null, recalled: null },
        { confidence: 0.28, trigger: 'Log aggregation via ELK', recalled: 'Never' },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
      ],
      // Security: very sparse
      [
        { confidence: 0.25, trigger: 'Rotate secrets quarterly', recalled: 'Never' },
        { confidence: 0.2, trigger: 'Audit IAM roles monthly', recalled: 'Never' },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
        { confidence: null, trigger: null, recalled: null },
      ],
    ]
  };

  function getConfidenceClass(confidence) {
    if (confidence === null) return 'cell-empty';
    if (confidence >= 0.8) return 'cell-high';
    if (confidence >= 0.5) return 'cell-medium';
    if (confidence >= 0.3) return 'cell-low';
    return 'cell-critical';
  }

  function getConfidenceLabel(confidence) {
    if (confidence === null) return 'No data';
    if (confidence >= 0.8) return 'High';
    if (confidence >= 0.5) return 'Medium';
    if (confidence >= 0.3) return 'Low';
    return 'Critical';
  }

  const grid = document.getElementById('heatmap');
  const tooltip = document.getElementById('heatmap-tooltip');
  const tooltipTrigger = document.getElementById('tooltip-trigger');
  const tooltipConfidence = document.getElementById('tooltip-confidence');
  const tooltipRecalled = document.getElementById('tooltip-recalled');
  const detailPanel = document.getElementById('heatmap-detail');
  const detailTitle = document.getElementById('detail-title');
  const detailBody = document.getElementById('detail-body');

  // Build rows
  heatmapData.periods.forEach((period, periodIdx) => {
    // Row label
    const label = document.createElement('div');
    label.className = 'heatmap-row-label';
    label.textContent = period;
    grid.appendChild(label);

    // Cells for each topic
    heatmapData.topics.forEach((topic, topicIdx) => {
      const cellData = heatmapData.cells[topicIdx][periodIdx];
      const cell = document.createElement('div');
      cell.className = `heatmap-cell ${getConfidenceClass(cellData.confidence)}`;
      cell.dataset.topic = topic;
      cell.dataset.period = period;
      cell.dataset.topicIdx = topicIdx;

      if (cellData.confidence !== null) {
        cell.dataset.confidence = cellData.confidence;
        cell.dataset.trigger = cellData.trigger;
        cell.dataset.recalled = cellData.recalled;
      }

      // Hover events
      cell.addEventListener('mouseenter', (e) => {
        if (cellData.confidence === null) {
          tooltipTrigger.textContent = `${topic} / ${period}`;
          tooltipConfidence.textContent = 'No memory stored';
          tooltipRecalled.textContent = '';
        } else {
          tooltipTrigger.textContent = cellData.trigger;
          tooltipConfidence.textContent = `Confidence: ${cellData.confidence.toFixed(2)} (${getConfidenceLabel(cellData.confidence)})`;
          tooltipRecalled.textContent = `Last recalled: ${cellData.recalled}`;
        }
        tooltip.classList.remove('hidden');
        positionTooltip(e);
      });

      cell.addEventListener('mousemove', (e) => {
        positionTooltip(e);
      });

      cell.addEventListener('mouseleave', () => {
        tooltip.classList.add('hidden');
      });

      // Click for dim regions
      cell.addEventListener('click', () => {
        // Clear previous selections
        document.querySelectorAll('.heatmap-cell.cell-selected').forEach(c => c.classList.remove('cell-selected'));

        if (topicIdx === 3) { // Monitoring
          cell.classList.add('cell-selected');
          detailTitle.textContent = `Monitoring -- Weak Coverage`;
          detailBody.textContent = '3 learnings, all below 0.5 confidence, never recalled. Topics include alerting thresholds, latency dashboards, and log aggregation. These memories exist in storage but have never been activated during a run.';
          detailPanel.classList.remove('hidden');
        } else if (topicIdx === 4) { // Security
          cell.classList.add('cell-selected');
          detailTitle.textContent = `Security -- No Recent Coverage`;
          detailBody.textContent = '2 learnings from 6 months ago, both below 0.3 confidence. No new security-related memories have been stored in 5 months. Consider directed learning sessions for secret rotation and IAM auditing.';
          detailPanel.classList.remove('hidden');
        } else {
          detailPanel.classList.add('hidden');
        }
      });

      grid.appendChild(cell);
    });
  });

  function positionTooltip(e) {
    const container = document.querySelector('.demo-container');
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left + 12;
    const y = e.clientY - rect.top - 10;
    tooltip.style.left = `${Math.min(x, rect.width - 290)}px`;
    tooltip.style.top = `${y}px`;
  }
</script>
