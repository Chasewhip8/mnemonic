---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('memory-commons')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="demo-container border border-brass/20 rounded-sm bg-void-deep overflow-hidden">
      <!-- Demo Header -->
      <div class="flex items-center justify-between px-5 py-3 border-b border-brass/10 bg-steel/50">
        <div class="flex items-center gap-3">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass">Memory Commons</span>
          <span class="font-mono text-[10px] text-chrome-dark/40">shared scope</span>
        </div>
        <div class="flex gap-2">
          <button id="tab-shared" class="commons-tab active font-mono text-[10px] px-3 py-1 rounded-sm border border-brass/20 bg-brass/10 text-brass cursor-pointer transition-colors">
            Shared (10)
          </button>
          <button id="tab-contested" class="commons-tab font-mono text-[10px] px-3 py-1 rounded-sm border border-chrome-dark/10 bg-transparent text-chrome-dark/40 cursor-pointer transition-colors hover:text-chrome-dark/60">
            Contested (2)
          </button>
          <button id="tab-moderation" class="commons-tab font-mono text-[10px] px-3 py-1 rounded-sm border border-chrome-dark/10 bg-transparent text-chrome-dark/40 cursor-pointer transition-colors hover:text-chrome-dark/60">
            Moderation Queue (1)
          </button>
        </div>
      </div>

      <div class="flex">
        <!-- Main content area -->
        <div class="flex-1 p-5" id="commons-main">
          <!-- Shared view -->
          <div id="view-shared" class="commons-view">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3" id="shared-grid">
              <!-- Cards injected by JS -->
            </div>
          </div>

          <!-- Contested view -->
          <div id="view-contested" class="commons-view hidden">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3" id="contested-grid">
              <!-- Contested cards injected by JS -->
            </div>
          </div>

          <!-- Moderation view -->
          <div id="view-moderation" class="commons-view hidden">
            <div id="moderation-grid">
              <!-- Moderation cards injected by JS -->
            </div>
          </div>
        </div>

        <!-- Contributors sidebar -->
        <div class="w-48 border-l border-brass/10 p-4 hidden md:block">
          <div class="font-mono text-[9px] font-bold tracking-widest uppercase text-chrome-dark/30 mb-3">Contributors</div>
          <div id="contributors-list" class="space-y-2">
            <!-- Injected by JS -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>

  <p>
    Imagine opening a dashboard and seeing not what you know, but what everyone knows. The Memory Commons is a shared view into collective intelligence -- a space where agents and humans contribute to a living body of organizational knowledge. It is not a wiki in the traditional sense, because nobody sat down and wrote these entries. They were born from real work: deployments that failed, tests that revealed edge cases, migrations that broke in unexpected ways. Each entry carries the fingerprint of its origin.
  </p>
  <p>
    The interface presents learnings grouped by topic clusters. Deployment knowledge in one region, testing patterns in another, infrastructure wisdom in a third. Each card displays its trigger condition, its distilled learning, who contributed it, how many times it has been recalled by others, and how many agents or humans have endorsed it as accurate. The confidence bar beneath each card is not static -- it shifts as endorsements accumulate or challenges arise.
  </p>
  <p>
    What makes this different from a knowledge base is the social layer. Agents and humans can endorse learnings they find accurate, or challenge learnings they believe are wrong or outdated. Challenged learnings do not disappear -- they move to a contested section, marked with amber borders, awaiting resolution. This creates a visible marketplace of ideas where knowledge must earn its place.
  </p>
  <p>
    The moderation queue surfaces contested learnings that need human judgment. When <code>deploy-bot</code> says "always use port 8080 for staging" and <code>monitor-bot</code> says "port 8080 causes conflicts on staging-02," someone needs to reconcile these claims. The Commons makes that conflict visible rather than letting it fester in silent contradiction.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>
    The Memory Commons reveals something fundamental about organizational knowledge: it is not a document. It is a living, contested, evolving organism. Traditional wikis treat knowledge as settled text that someone authored and everyone else consumes. But in practice, knowledge is more like a conversation that never ends. Someone contributes an insight, others validate or challenge it, and over time the surviving entries represent something closer to truth than any single author could produce.
  </p>
  <p>
    This pattern also reveals the economics of contribution. In any shared knowledge system, some participants are natural producers and others are natural consumers. The Commons makes this visible: <code>deploy-bot</code> with 15 contributed learnings, <code>doc-writer</code> with 3. This is not inherently a problem -- a well-functioning ecosystem needs both producers and consumers -- but it becomes a problem when producers go offline and nobody notices the inflow has stopped.
  </p>
  <p>
    Perhaps most importantly, the Commons reveals trust dynamics. An endorsement is a signal: "I have independently verified this." A challenge is a different signal: "My experience contradicts this." When you see a learning with 12 endorsements and zero challenges, you can trust it differently than one with 2 endorsements and 3 challenges. These social signals are information that raw data alone cannot provide.
  </p>
  <p>
    The contested section is where the real learning happens. Most knowledge management systems hide disagreements. The Commons surfaces them as features, not bugs. A contested learning is an invitation to investigate, not an error to sweep away.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>
    Deja's <code>shared</code> scope already provides the foundation for a Memory Commons. When a learning is stored with <code>scope: "shared"</code>, it becomes visible to all agents and all users on the team. The missing pieces are social: who contributed this learning, who has endorsed it, who has challenged it, and what the resolution was.
  </p>
  <p>
    The data model extension is straightforward. Each learning needs a <code>contributed_by</code> field (already partially present as metadata), an <code>endorsed_by[]</code> array tracking which agents or users have independently confirmed the learning, and a <code>challenged_by[]</code> array with optional reasons. A <code>status</code> field distinguishes between <code>active</code>, <code>contested</code>, and <code>resolved</code> states.
  </p>
  <p>
    The API surface would extend naturally from existing endpoints. <code>POST /learnings/:id/endorse</code> and <code>POST /learnings/:id/challenge</code> would handle the social actions. A <code>GET /learnings/contested</code> endpoint would power the moderation queue. The recall endpoint already filters by scope -- adding filters for endorsement count and contested status requires minimal additional query logic.
  </p>
  <p>
    The deeper question is about the <code>state_resolve</code> mechanism. When an agent calls <code>state_resolve</code> and encounters a contested learning, what should happen? One approach: contested learnings are still returned but flagged, letting the consuming agent decide whether to trust them. Another: contested learnings are excluded from automatic recall until resolved. The right answer probably depends on the stakes -- low-confidence contested learnings about formatting preferences are different from contested learnings about production deployment procedures.
  </p>

  <h2 id="design-tensions">Design tensions</h2>

  <p>
    <strong>Shared knowledge is political.</strong> The moment you create a shared knowledge base, you create a space where different perspectives compete. When <code>deploy-bot</code> and <code>monitor-bot</code> disagree about port allocation, the disagreement is not just technical -- it reflects different vantage points in the system. The deploy agent sees what works at deployment time. The monitoring agent sees what fails at runtime. Both are correct from their perspective. The Commons needs to hold both truths simultaneously until a human (or a higher-authority agent) resolves the tension.
  </p>
  <p>
    <strong>Endorsement gaming is real.</strong> If endorsements boost a learning's visibility or confidence, agents have an incentive to endorse liberally. A deployment agent that endorses its own learnings creates a feedback loop. The system needs rules: can an agent endorse its own contributions? Should endorsements from agents that have never actually used the learning carry the same weight as endorsements from agents that recalled and applied it successfully?
  </p>
  <p>
    <strong>The moderation bottleneck.</strong> If contested learnings require human resolution, the moderation queue becomes a bottleneck. Three contested learnings are manageable. Three hundred are not. This suggests a need for automated resolution heuristics -- perhaps a contested learning with 10 endorsements and 1 challenge from a low-activity agent can be auto-resolved. But automated resolution is itself a design choice with consequences.
  </p>
  <p>
    <strong>Scope boundaries blur.</strong> When does an agent-scoped learning deserve promotion to the Commons? The answer is rarely clear-cut. A learning that is useful to one agent might be noise to everyone else, or it might be the most important insight in the system. The Commons needs a mechanism for nomination -- agents or humans proposing that a private learning be elevated to shared status -- with its own review process.
  </p>
  <p>
    The Memory Commons is, at its core, an experiment in collective intelligence. It asks whether a group of agents and humans, each contributing from their own experience, can build something wiser than any individual participant. The history of human wikis suggests the answer is yes, but only with careful governance. The question for agent systems is whether that governance can itself be partially automated -- and what we lose when it is.
  </p>
</ResearchLayout>

<style>
  .demo-container {
    box-shadow:
      inset 0 1px 0 rgba(201, 169, 97, 0.05),
      0 4px 24px rgba(0, 0, 0, 0.5);
  }

  .commons-tab.active {
    background: rgba(201, 169, 97, 0.1);
    border-color: rgba(201, 169, 97, 0.2);
    color: #c9a961;
  }

  .learning-card {
    background: #1a1a1a;
    border: 1px solid rgba(201, 169, 97, 0.1);
    border-radius: 2px;
    padding: 14px;
    transition: border-color 0.3s, transform 0.2s;
  }

  .learning-card:hover {
    border-color: rgba(201, 169, 97, 0.2);
  }

  .learning-card.contested {
    border-color: rgba(234, 179, 8, 0.4);
    background: rgba(234, 179, 8, 0.03);
  }

  .learning-card .trigger {
    font-family: var(--font-family-mono);
    font-size: 10px;
    color: rgba(184, 184, 184, 0.4);
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .learning-card .learning-text {
    font-family: var(--font-family-serif);
    font-size: 13px;
    color: #e8e8e8;
    line-height: 1.5;
    margin-bottom: 8px;
  }

  .learning-card .meta {
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: var(--font-family-mono);
    font-size: 10px;
    color: rgba(184, 184, 184, 0.4);
    margin-bottom: 8px;
  }

  .learning-card .contributor {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .contributor-icon {
    width: 14px;
    height: 14px;
    border-radius: 2px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: 700;
    color: #0a0a0a;
  }

  .contributor-icon.agent {
    background: #c9a961;
  }

  .contributor-icon.human {
    background: #60a5fa;
  }

  .confidence-bar {
    height: 3px;
    background: rgba(201, 169, 97, 0.1);
    border-radius: 1px;
    overflow: hidden;
    margin-bottom: 10px;
  }

  .confidence-fill {
    height: 100%;
    background: #c9a961;
    border-radius: 1px;
    transition: width 0.3s;
  }

  .card-actions {
    display: flex;
    gap: 6px;
  }

  .card-actions button {
    font-family: var(--font-family-mono);
    font-size: 10px;
    padding: 3px 8px;
    border-radius: 2px;
    border: 1px solid rgba(184, 184, 184, 0.1);
    background: transparent;
    color: rgba(184, 184, 184, 0.5);
    cursor: pointer;
    transition: all 0.2s;
  }

  .card-actions button:hover {
    border-color: rgba(201, 169, 97, 0.3);
    color: #c9a961;
  }

  .card-actions button.challenge-btn:hover {
    border-color: rgba(234, 179, 8, 0.3);
    color: #eab308;
  }

  .endorse-pop {
    animation: pop 0.3s ease-out;
  }

  @keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  .contrib-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: var(--font-family-mono);
    font-size: 10px;
    color: rgba(184, 184, 184, 0.5);
  }

  .moderation-card {
    background: #1a1a1a;
    border: 1px solid rgba(234, 179, 8, 0.3);
    border-radius: 2px;
    padding: 16px;
    background: rgba(234, 179, 8, 0.03);
  }

  .moderation-card .resolve-btn {
    font-family: var(--font-family-mono);
    font-size: 10px;
    padding: 4px 12px;
    border-radius: 2px;
    border: 1px solid rgba(201, 169, 97, 0.3);
    background: rgba(201, 169, 97, 0.1);
    color: #c9a961;
    cursor: pointer;
    transition: all 0.2s;
  }

  .moderation-card .resolve-btn:hover {
    background: rgba(201, 169, 97, 0.2);
  }
</style>

<script>
  const learnings = [
    { id: 1, trigger: 'deploy:auth-service', text: 'Always run database migrations before deploying auth-service to prevent schema mismatch errors.', contributor: 'deploy-bot', type: 'agent', recalls: 12, endorsements: 4, confidence: 0.92, topic: 'deployment' },
    { id: 2, trigger: 'test:integration', text: 'Integration tests for payment flow require the sandbox API key, not production. Mock the gateway in CI.', contributor: 'test-runner', type: 'agent', recalls: 8, endorsements: 6, confidence: 0.88, topic: 'testing' },
    { id: 3, trigger: 'deploy:staging', text: 'Staging deploys on Thursdays often conflict with the weekly data sync job. Schedule around it.', contributor: 'human:alice', type: 'human', recalls: 5, endorsements: 3, confidence: 0.75, topic: 'deployment' },
    { id: 4, trigger: 'monitor:latency', text: 'Latency spikes above 200ms on the /api/search endpoint correlate with cold cache after nightly restart.', contributor: 'monitor-bot', type: 'agent', recalls: 15, endorsements: 7, confidence: 0.95, topic: 'monitoring' },
    { id: 5, trigger: 'test:unit', text: 'Unit tests for the recommendation engine are flaky when run in parallel. Use --runInBand flag.', contributor: 'test-runner', type: 'agent', recalls: 9, endorsements: 5, confidence: 0.82, topic: 'testing' },
    { id: 6, trigger: 'deploy:rollback', text: 'Rollbacks on the user-service require clearing the Redis session cache manually afterward.', contributor: 'deploy-bot', type: 'agent', recalls: 3, endorsements: 2, confidence: 0.70, topic: 'deployment' },
    { id: 7, trigger: 'infra:dns', text: 'DNS propagation for subdomain changes takes 15-30 minutes in our setup despite low TTL values.', contributor: 'human:bob', type: 'human', recalls: 7, endorsements: 4, confidence: 0.85, topic: 'infrastructure' },
    { id: 8, trigger: 'test:e2e', text: 'End-to-end tests pass locally but fail in CI due to different Chrome versions. Pin chromium in Dockerfile.', contributor: 'test-runner', type: 'agent', recalls: 11, endorsements: 8, confidence: 0.93, topic: 'testing' },
    { id: 9, trigger: 'deploy:config', text: 'Environment variables for the notification service must be set before the container starts, not injected at runtime.', contributor: 'deploy-bot', type: 'agent', recalls: 6, endorsements: 3, confidence: 0.78, topic: 'deployment' },
    { id: 10, trigger: 'monitor:memory', text: 'The analytics worker leaks memory over 48 hours. Restart it on a 24-hour cron cycle as a workaround.', contributor: 'monitor-bot', type: 'agent', recalls: 4, endorsements: 2, confidence: 0.68, topic: 'monitoring' },
  ];

  const contestedLearnings = [
    { id: 101, trigger: 'deploy:port', text: 'Always use port 8080 for staging deployments to maintain consistency across services.', contributor: 'deploy-bot', type: 'agent', recalls: 5, endorsements: 2, confidence: 0.55, topic: 'deployment', challengedBy: 'monitor-bot', challengeReason: 'Port 8080 conflicts with the monitoring dashboard on staging-02. Use 8081 instead.' },
    { id: 102, trigger: 'test:timeout', text: 'Set test timeout to 5000ms for all integration tests to avoid false failures.', contributor: 'test-runner', type: 'agent', recalls: 3, endorsements: 1, confidence: 0.45, topic: 'testing', challengedBy: 'human:alice', challengeReason: 'A 5-second timeout masks genuinely slow tests. 2000ms is a better default with explicit overrides.' },
  ];

  const contributors = [
    { name: 'deploy-bot', type: 'agent', count: 15 },
    { name: 'test-runner', type: 'agent', count: 12 },
    { name: 'monitor-bot', type: 'agent', count: 8 },
    { name: 'human:alice', type: 'human', count: 5 },
    { name: 'human:bob', type: 'human', count: 3 },
    { name: 'doc-writer', type: 'agent', count: 2 },
  ];

  function renderCard(l: typeof learnings[0], contested = false) {
    const iconClass = l.type === 'agent' ? 'agent' : 'human';
    const iconLetter = l.type === 'agent' ? 'A' : 'H';
    return `
      <div class="learning-card ${contested ? 'contested' : ''}" data-id="${l.id}">
        <div class="trigger">when: ${l.trigger}</div>
        <div class="learning-text">${l.text}</div>
        <div class="meta">
          <span class="contributor">
            <span class="contributor-icon ${iconClass}">${iconLetter}</span>
            ${l.contributor}
          </span>
          <span>recalled ${l.recalls} times</span>
          <span class="endorse-count" data-id="${l.id}">${l.endorsements} endorsements</span>
        </div>
        <div class="confidence-bar">
          <div class="confidence-fill" style="width: ${l.confidence * 100}%"></div>
        </div>
        <div class="card-actions">
          <button class="endorse-btn" data-id="${l.id}">+ Endorse</button>
          ${!contested ? `<button class="challenge-btn" data-id="${l.id}">? Challenge</button>` : ''}
        </div>
        ${contested && (l as any).challengeReason ? `
          <div style="margin-top: 8px; padding: 8px; background: rgba(234,179,8,0.05); border-radius: 2px; font-family: var(--font-family-mono); font-size: 10px; color: #eab308;">
            Challenged by ${(l as any).challengedBy}: "${(l as any).challengeReason}"
          </div>
        ` : ''}
      </div>
    `;
  }

  function renderContributors() {
    const list = document.getElementById('contributors-list');
    if (!list) return;
    list.innerHTML = contributors.map(c => {
      const iconClass = c.type === 'agent' ? 'agent' : 'human';
      const iconLetter = c.type === 'agent' ? 'A' : 'H';
      return `
        <div class="contrib-item">
          <span class="contributor-icon ${iconClass}">${iconLetter}</span>
          <span>${c.name}</span>
          <span style="margin-left: auto; color: rgba(201,169,97,0.5);">${c.count}</span>
        </div>
      `;
    }).join('');
  }

  function renderShared() {
    const grid = document.getElementById('shared-grid');
    if (!grid) return;
    grid.innerHTML = learnings.map(l => renderCard(l)).join('');
  }

  function renderContested() {
    const grid = document.getElementById('contested-grid');
    if (!grid) return;
    grid.innerHTML = contestedLearnings.map(l => renderCard(l, true)).join('');
  }

  function renderModeration() {
    const grid = document.getElementById('moderation-grid');
    if (!grid) return;
    const item = contestedLearnings[0];
    grid.innerHTML = `
      <div class="moderation-card">
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: #eab308; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Awaiting resolution</div>
        <div style="font-family: var(--font-family-serif); font-size: 14px; color: #e8e8e8; margin-bottom: 10px;">${item.text}</div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
          <div style="padding: 10px; border: 1px solid rgba(201,169,97,0.15); border-radius: 2px;">
            <div style="font-family: var(--font-family-mono); font-size: 9px; color: rgba(201,169,97,0.5); margin-bottom: 4px;">ORIGINAL</div>
            <div style="font-family: var(--font-family-serif); font-size: 12px; color: #b8b8b8;">${item.contributor}: "${item.text}"</div>
            <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.3); margin-top: 4px;">${item.endorsements} endorsements</div>
          </div>
          <div style="padding: 10px; border: 1px solid rgba(234,179,8,0.2); border-radius: 2px; background: rgba(234,179,8,0.02);">
            <div style="font-family: var(--font-family-mono); font-size: 9px; color: #eab308; margin-bottom: 4px;">CHALLENGE</div>
            <div style="font-family: var(--font-family-serif); font-size: 12px; color: #b8b8b8;">${(item as any).challengedBy}: "${(item as any).challengeReason}"</div>
          </div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="resolve-btn" onclick="this.textContent='Resolved'; this.style.opacity='0.5'; this.disabled=true;">Keep Original</button>
          <button class="resolve-btn" onclick="this.textContent='Resolved'; this.style.opacity='0.5'; this.disabled=true;">Accept Challenge</button>
          <button class="resolve-btn" onclick="this.textContent='Resolved'; this.style.opacity='0.5'; this.disabled=true;">Merge Both</button>
        </div>
      </div>
    `;
  }

  // Tab switching
  document.querySelectorAll('.commons-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.commons-tab').forEach(t => {
        t.classList.remove('active');
        (t as HTMLElement).style.background = 'transparent';
        (t as HTMLElement).style.borderColor = 'rgba(184,184,184,0.1)';
        (t as HTMLElement).style.color = 'rgba(184,184,184,0.4)';
      });
      (tab as HTMLElement).classList.add('active');

      document.querySelectorAll('.commons-view').forEach(v => v.classList.add('hidden'));

      const id = tab.id;
      if (id === 'tab-shared') document.getElementById('view-shared')?.classList.remove('hidden');
      if (id === 'tab-contested') document.getElementById('view-contested')?.classList.remove('hidden');
      if (id === 'tab-moderation') document.getElementById('view-moderation')?.classList.remove('hidden');
    });
  });

  // Endorse handling
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('endorse-btn')) {
      const id = target.dataset.id;
      const countEl = document.querySelector(`.endorse-count[data-id="${id}"]`);
      if (countEl) {
        const current = parseInt(countEl.textContent || '0');
        countEl.textContent = `${current + 1} endorsements`;
        countEl.classList.remove('endorse-pop');
        void (countEl as HTMLElement).offsetWidth;
        countEl.classList.add('endorse-pop');
      }
      target.textContent = 'Endorsed';
      target.style.color = '#c9a961';
      target.style.borderColor = 'rgba(201,169,97,0.3)';
      (target as HTMLButtonElement).disabled = true;
    }

    if (target.classList.contains('challenge-btn')) {
      const id = target.dataset.id;
      const card = target.closest('.learning-card');
      if (card) {
        card.classList.add('contested');
        target.textContent = 'Challenged';
        target.style.color = '#eab308';
        target.style.borderColor = 'rgba(234,179,8,0.3)';
        (target as HTMLButtonElement).disabled = true;
      }
    }
  });

  // Initialize
  renderShared();
  renderContested();
  renderModeration();
  renderContributors();
</script>
