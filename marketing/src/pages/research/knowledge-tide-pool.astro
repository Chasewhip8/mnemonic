---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import DoItWithDeja from '../../components/DoItWithDeja.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('knowledge-tide-pool')!;
---

<ResearchLayout concept={concept}>
  <!-- Demo -->
  <div slot="demo">
    <div class="tp-demo bg-void-deep border border-brass/15 rounded-sm overflow-hidden">
      <!-- Toolbar: wraps on small screens -->
      <div class="flex flex-wrap items-center gap-x-4 gap-y-3 px-4 py-3 border-b border-brass/10 bg-steel/50">
        <div class="flex flex-wrap items-center gap-2">
          <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass/70">Knowledge Tide Pool</span>
          <div class="flex flex-wrap items-center gap-1.5">
            <span class="font-mono text-[9px] text-chrome-dark/30">Context:</span>
            <button class="tp-context-btn active font-mono text-[10px] px-2.5 py-1 rounded-sm transition-all" data-context="deploying">deploying</button>
            <button class="tp-context-btn font-mono text-[10px] px-2.5 py-1 rounded-sm transition-all" data-context="debugging">debugging tests</button>
            <button class="tp-context-btn font-mono text-[10px] px-2.5 py-1 rounded-sm transition-all" data-context="writing">writing docs</button>
          </div>
        </div>
        <div class="flex flex-wrap items-center gap-3 sm:gap-4 ml-0 sm:ml-auto">
          <div class="flex items-center gap-2">
            <span class="font-mono text-[9px] text-chrome-dark/30">Max pool size:</span>
            <input type="range" id="tp-max-slider" min="4" max="12" value="10" class="tp-slider w-16" />
            <span id="tp-max-label" class="font-mono text-[10px] text-brass/60">10</span>
          </div>
          <span id="tp-refresh-count" class="font-mono text-[10px] text-chrome-dark/30">Pool refreshed 0 times</span>
        </div>
      </div>

      <!-- Current context display -->
      <div class="px-4 py-2 border-b border-brass/5 bg-steel/20 min-w-0">
        <div class="flex flex-wrap items-center gap-x-2 gap-y-1">
          <span class="font-mono text-[9px] text-chrome-dark/30 uppercase tracking-wider shrink-0">Current context:</span>
          <span id="tp-context-display" class="font-mono text-[11px] text-brass/80 wrap-break-word">"deploying auth service to staging"</span>
        </div>
      </div>

      <!-- Pool visualization -->
      <div class="tp-pool-area relative" style="height: 380px;">
        <!-- Ocean background (outer area with dots) -->
        <div class="tp-ocean absolute inset-0 overflow-hidden" id="tp-ocean">
          <!-- Ocean dots rendered by JS -->
        </div>

        <!-- The pool: responsive width -->
        <div class="tp-pool absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(100%-2rem,520px)] max-w-full" id="tp-pool" style="height: 280px;">
          <div class="tp-pool-inner relative w-full h-full rounded-lg overflow-hidden">
            <div class="tp-water-surface absolute inset-0"></div>
            <div class="tp-pool-label absolute top-2 left-3 font-mono text-[9px] tracking-widest uppercase text-brass/25 z-10">Active Pool</div>
            <!-- Bubbles rendered by JS -->
            <div id="tp-bubbles" class="relative w-full h-full z-10"></div>
          </div>
        </div>

        <!-- Ocean label -->
        <div class="absolute top-3 right-4 font-mono text-[9px] tracking-widest uppercase text-chrome-dark/15">Available memories</div>
      </div>
    </div>
  </div>

  <!-- ToC -->
  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#do-it-with-deja" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Do it with deja</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
    <a href="#the-paradigm-shift" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The paradigm shift</a>
  </Fragment>

  <!-- Content -->
  <h2 id="the-experience">The experience</h2>

  <p>The pool is alive. When you first open it, eight or nine memory bubbles float gently inside a dark, rounded container. Each bubble is a small card drifting with a slow, organic motion -- not random, but not mechanical either. The kind of motion that makes you watch for a moment before you start reading. Each bubble shows a trigger and a confidence score: "dry-run deploys 0.9", "pin base images 0.87", "blue-green rollback 0.73". These are the memories the system considers relevant right now, given your current context of deploying an auth service to staging.</p>

  <p>Outside the pool, in the surrounding ocean, you see dozens of tiny dots. Each dot is a memory that exists in the shared pool but is not currently relevant. They are available but dormant. The distinction between "in the pool" and "in the ocean" is the distinction between ambient and latent -- between what the system thinks you need and everything else it knows.</p>

  <p>You click the "debugging tests" context button. The pool transforms. Three bubbles drift outward and fade -- deployment-specific knowledge flowing back into the ocean. Two new bubbles flow in from the edges, fading into visibility: "isolate flaky tests 0.82", "check test fixtures first 0.88". The transition takes about a second. It is smooth enough to feel natural and fast enough to feel responsive. The pool has refreshed itself. The counter ticks up: "Pool refreshed 1 time this session."</p>

  <p>You notice one bubble you want to keep regardless of context: "always check env vars before running." You click its pin button. A small indicator appears on the bubble. Now when you switch to "writing docs" context and the pool refreshes again, that pinned bubble stays put while others flow in and out around it. You also see a memory that seems irrelevant -- a leftover from a previous context. You click its drain button and it fades away, sinking out of the pool. The max pool size slider at the top lets you control density: slide it down to 6, and the least relevant bubbles drift out to make room.</p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>The tide pool makes the dynamic nature of relevance viscerally apparent. In a traditional memory interface -- a table, a search box -- you ask for memories and receive them. The assumption is that relevance is a function of your query. But relevance is not static. It changes as your context changes, and your context changes continuously as you work. A memory about deployment rollback procedures is critical when you are deploying, irrelevant when you are writing documentation, and suddenly critical again when the documentation is about deployment procedures.</p>

  <p>What the tide pool reveals is the temporal texture of knowledge work. There are periods of stability where the same set of memories remains relevant for minutes or hours. Then there are phase transitions -- switching from deploying to debugging, from debugging to documenting -- where the relevant set changes almost entirely. The pool makes these transitions visible. You can see the knowledge state reshuffling in real time, and in that reshuffling, you begin to understand the topology of your own work: which memories span multiple contexts (the pinned ones), which are narrowly relevant (the ones that appear and disappear), and which are so peripheral that they never enter the pool at all.</p>

  <p>The pool also reveals something about quantity. The max pool size slider is not just a UI control -- it is a cognitive constraint. Human working memory holds roughly seven items. An agent's context window is finite. The tide pool enforces a limit not because the system cannot track more memories, but because usefulness degrades with volume. Ten highly relevant memories are more valuable than fifty moderately relevant ones. The slider makes this tradeoff explicit and adjustable.</p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>The tide pool maps to deja's <code>/inject</code> endpoint running continuously. Today, injection is a discrete operation: an agent calls <code>/inject</code> with a context string, and deja returns the top-k most relevant memories. This works well for single-shot queries. The tide pool extends this into a streaming model. Every time the working state updates -- a new file opened, a command run, an error encountered -- the system re-runs injection with the updated context. The pool is the visual representation of the injection result at any given moment.</p>

  <p>The implementation requires a lightweight context-change detection layer. Not every keystroke should trigger re-injection. Instead, the system watches for meaningful context shifts: switching files, running commands, changing branches. When a shift is detected, the new context is sent to <code>/inject</code>, and the response is diffed against the current pool. Memories that are in the new result but not in the current pool flow in. Memories that are in the current pool but not in the new result flow out -- unless they are pinned.</p>

  <p>Pinning introduces client-side state that interacts with server-side relevance. A pinned memory is always included in the active set, regardless of what <code>/inject</code> returns. This means the effective pool size for dynamic memories is <code>max_pool_size - pinned_count</code>. If you pin five memories and set the max to ten, only five slots remain for the injection system to fill. This creates an interesting tension between human curation and algorithmic relevance.</p>

  <p>The drain operation is simpler: it is a client-side exclusion list. A drained memory is temporarily suppressed from the pool, even if <code>/inject</code> would return it. The exclusion persists for the current session. This gives the user a correction mechanism when the relevance algorithm surfaces something they know is not useful -- a feedback signal that could, in a future iteration, be used to fine-tune the embedding model itself.</p>

  <DoItWithDeja
    blurb="On context change: POST /inject with new context. setInterval or event-driven. Render results as pool; pin = client state."
    snippets={[
      {
        label: 'Inject on context change',
        code: `function onContextChange(ctx) {
  fetch('/inject', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ context: ctx })
  }).then(r => r.json()).then(({ learnings }) => updatePool(learnings));
}
// Wire to file switch, command run, etc.`,
      },
    ]}
  />

  <h2 id="design-tensions">Design tensions</h2>

  <p>The central tension of the tide pool is the cost of continuous injection. Every context change triggers an embedding computation and a vector search. For a memory pool of a few hundred entries, this is fast -- tens of milliseconds. For a pool of thousands, with multiple agents contributing, the latency starts to matter. The pool needs to feel instantaneous. A 500-millisecond delay between context change and pool refresh breaks the illusion of ambient intelligence. It turns the tide pool back into a search box with extra animation.</p>

  <p>There is also a design question about what constitutes "context." The demo uses simple preset buttons, but in production, context is messy. It is the current file, the recent git diff, the last error message, the Slack channel you are reading, the ticket you are working on. Constructing a context string from this ambient information is itself a significant engineering challenge. The pool's quality is bounded by the quality of its context signal. Garbage context produces garbage relevance.</p>

  <p>The most provocative tension is between user control and system autonomy. The tide pool makes decisions about what you should be thinking about. It promotes certain memories into your attention and demotes others. The pin and drain buttons give you override capability, but the default behavior is algorithmic curation of your cognitive context. This is powerful when it works -- surfacing exactly the right memory at exactly the right moment. It is disorienting when it does not -- when the pool contains memories you do not understand or need, or when it flushes a memory you were about to reference.</p>

  <h2 id="the-paradigm-shift">The paradigm shift</h2>

  <p>Today, deja's <code>/inject</code> is pull-based. An agent decides to query memory, constructs a context, and receives results. The agent is in control. It chooses when to remember. The tide pool inverts this. Memory is push-based. The system decides what is relevant and places it in the agent's awareness without being asked. The agent does not choose to remember -- it is reminded.</p>

  <p>This is not a small change. It is a fundamental shift in the relationship between agent and memory. Pull-based memory treats the knowledge store as a library: go there when you need something, search, retrieve, return to work. Push-based memory treats the knowledge store as a colleague: someone who is watching what you do and volunteering relevant information without waiting to be asked. The library model scales well and is easy to reason about. The colleague model is more useful but harder to control.</p>

  <p>The biological parallel is instructive. Human memory is overwhelmingly push-based. You do not decide to remember that the stove is hot when you see a flame. The association fires automatically. The smell of a specific food recalls a specific place. A line of code recalls the bug it caused last week. These memories are not retrieved on demand -- they are activated by context. The tide pool is an attempt to give agent memory the same ambient, contextual quality. Not a filing cabinet you visit, but a current that carries relevant knowledge to where it is needed.</p>

  <p>The implications extend beyond individual agents. In a multi-agent system, push-based memory means that when Agent A learns something new, it can immediately flow into Agent B's pool if Agent B's context makes it relevant. Knowledge propagation becomes real-time rather than query-time. The tide pool is not just an interface -- it is an architecture. It changes when knowledge moves, and that changes everything downstream.</p>

</ResearchLayout>

<style>
  .tp-demo {
    overflow: hidden;
  }

  .tp-context-btn {
    color: rgba(184, 184, 184, 0.4);
    background: transparent;
    border: 1px solid rgba(201, 169, 97, 0.1);
    cursor: pointer;
  }

  .tp-context-btn:hover {
    color: rgba(184, 184, 184, 0.7);
    background: rgba(201, 169, 97, 0.05);
  }

  .tp-context-btn.active {
    color: #c9a961;
    background: rgba(201, 169, 97, 0.1);
    border-color: rgba(201, 169, 97, 0.25);
  }

  .tp-slider {
    -webkit-appearance: none;
    appearance: none;
    height: 3px;
    background: rgba(201, 169, 97, 0.15);
    border-radius: 2px;
    outline: none;
  }

  .tp-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #c9a961;
    cursor: pointer;
  }

  .tp-pool-area {
    background: radial-gradient(ellipse at center, rgba(5, 5, 5, 0.3) 0%, rgba(5, 5, 5, 0.9) 100%);
  }

  .tp-pool-inner {
    background: linear-gradient(180deg,
      rgba(10, 15, 25, 0.9) 0%,
      rgba(8, 12, 22, 0.95) 50%,
      rgba(6, 10, 20, 0.9) 100%);
    border: 1px solid rgba(201, 169, 97, 0.12);
  }

  .tp-water-surface {
    background:
      radial-gradient(ellipse at 30% 20%, rgba(96, 165, 250, 0.03) 0%, transparent 50%),
      radial-gradient(ellipse at 70% 80%, rgba(201, 169, 97, 0.03) 0%, transparent 50%);
    animation: tp-water-ripple 8s ease-in-out infinite;
  }

  @keyframes tp-water-ripple {
    0%, 100% {
      background-position: 0% 0%, 100% 100%;
      opacity: 0.6;
    }
    25% {
      opacity: 1;
    }
    50% {
      background-position: 100% 100%, 0% 0%;
      opacity: 0.6;
    }
    75% {
      opacity: 1;
    }
  }

  .tp-bubble {
    position: absolute;
    background: rgba(26, 26, 26, 0.85);
    border: 1px solid rgba(201, 169, 97, 0.18);
    border-radius: 6px;
    padding: 6px 10px;
    cursor: default;
    transition: opacity 0.8s ease, transform 0.8s ease;
    white-space: nowrap;
    z-index: 5;
  }

  .tp-bubble.pinned {
    border-color: rgba(201, 169, 97, 0.4);
    box-shadow: 0 0 8px rgba(201, 169, 97, 0.1);
  }

  .tp-bubble .tp-bubble-text {
    font-family: var(--font-mono), monospace;
    font-size: 10px;
    color: rgba(232, 232, 232, 0.7);
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .tp-bubble .tp-bubble-conf {
    color: rgba(201, 169, 97, 0.6);
    font-size: 9px;
  }

  .tp-bubble .tp-bubble-actions {
    display: flex;
    gap: 3px;
    margin-left: 4px;
  }

  .tp-bubble .tp-bubble-btn {
    font-size: 8px;
    padding: 1px 4px;
    border-radius: 2px;
    border: 1px solid rgba(201, 169, 97, 0.1);
    background: transparent;
    color: rgba(184, 184, 184, 0.3);
    cursor: pointer;
    font-family: var(--font-mono), monospace;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    transition: all 0.2s ease;
  }

  .tp-bubble .tp-bubble-btn:hover {
    color: rgba(201, 169, 97, 0.8);
    border-color: rgba(201, 169, 97, 0.3);
  }

  .tp-bubble .tp-bubble-btn.drain:hover {
    color: rgba(239, 68, 68, 0.6);
    border-color: rgba(239, 68, 68, 0.2);
  }

  .tp-bubble.entering {
    opacity: 0;
    transform: scale(0.8);
  }

  .tp-bubble.visible {
    opacity: 1;
    transform: scale(1);
  }

  .tp-bubble.exiting {
    opacity: 0;
    transform: scale(0.7) translateY(10px);
  }

  .tp-pin-indicator {
    color: rgba(201, 169, 97, 0.5);
    font-size: 8px;
    margin-left: 2px;
  }

  .tp-ocean-dot {
    position: absolute;
    width: 3px;
    height: 3px;
    border-radius: 50%;
    background: rgba(184, 184, 184, 0.08);
    animation: tp-dot-drift 12s ease-in-out infinite;
  }

  @keyframes tp-dot-drift {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(2px, -3px); }
    50% { transform: translate(-1px, 2px); }
    75% { transform: translate(3px, 1px); }
  }
</style>

<script>
  interface Memory {
    trigger: string;
    confidence: number;
    contexts: string[];
    pinned?: boolean;
    drained?: boolean;
  }

  const allMemories: Memory[] = [
    { trigger: "dry-run deploys", confidence: 0.90, contexts: ["deploying"] },
    { trigger: "pin base images", confidence: 0.87, contexts: ["deploying"] },
    { trigger: "blue-green rollback", confidence: 0.73, contexts: ["deploying"] },
    { trigger: "check env vars", confidence: 0.92, contexts: ["deploying", "debugging"] },
    { trigger: "canary release 5%", confidence: 0.68, contexts: ["deploying"] },
    { trigger: "health check timeout", confidence: 0.81, contexts: ["deploying", "debugging"] },
    { trigger: "rollback on error rate", confidence: 0.77, contexts: ["deploying"] },
    { trigger: "staging parity", confidence: 0.85, contexts: ["deploying"] },
    { trigger: "notify on deploy start", confidence: 0.64, contexts: ["deploying"] },
    { trigger: "isolate flaky tests", confidence: 0.82, contexts: ["debugging"] },
    { trigger: "check test fixtures", confidence: 0.88, contexts: ["debugging"] },
    { trigger: "mock external calls", confidence: 0.79, contexts: ["debugging"] },
    { trigger: "bisect failing commit", confidence: 0.74, contexts: ["debugging"] },
    { trigger: "check race conditions", confidence: 0.71, contexts: ["debugging"] },
    { trigger: "log assertion context", confidence: 0.83, contexts: ["debugging"] },
    { trigger: "snapshot test updates", confidence: 0.66, contexts: ["debugging"] },
    { trigger: "parallel test isolation", confidence: 0.78, contexts: ["debugging"] },
    { trigger: "docstring conventions", confidence: 0.86, contexts: ["writing"] },
    { trigger: "code example format", confidence: 0.91, contexts: ["writing"] },
    { trigger: "API ref structure", confidence: 0.84, contexts: ["writing"] },
    { trigger: "changelog entries", confidence: 0.72, contexts: ["writing", "deploying"] },
    { trigger: "diagram as code", confidence: 0.69, contexts: ["writing"] },
    { trigger: "link to source", confidence: 0.77, contexts: ["writing"] },
    { trigger: "version in docs", confidence: 0.81, contexts: ["writing"] },
    { trigger: "glossary terms", confidence: 0.63, contexts: ["writing"] },
    { trigger: "migration guides", confidence: 0.75, contexts: ["writing", "deploying"] },
    { trigger: "error catalog", confidence: 0.80, contexts: ["debugging", "writing"] },
    { trigger: "runbook format", confidence: 0.73, contexts: ["writing", "deploying"] },
    { trigger: "schema versioning", confidence: 0.76, contexts: ["deploying", "debugging"] },
    { trigger: "secret rotation", confidence: 0.88, contexts: ["deploying"] },
    { trigger: "dependency audit", confidence: 0.70, contexts: ["debugging", "deploying"] },
    { trigger: "test coverage gates", confidence: 0.65, contexts: ["debugging"] },
    { trigger: "feature branch naming", confidence: 0.59, contexts: ["deploying", "writing"] },
  ];

  const contextLabels: Record<string, string> = {
    deploying: '"deploying auth service to staging"',
    debugging: '"debugging intermittent test failures in CI"',
    writing: '"writing API reference documentation"',
  };

  let currentContext = 'deploying';
  let maxPoolSize = 10;
  let refreshCount = 0;
  let activeBubbles: { memory: Memory; x: number; y: number; vx: number; vy: number; el?: HTMLElement }[] = [];
  let animFrameId: number;

  function getRelevantMemories(context: string, max: number): Memory[] {
    const matching = allMemories
      .filter(m => !m.drained && m.contexts.includes(context))
      .sort((a, b) => b.confidence - a.confidence);

    const pinned = allMemories.filter(m => m.pinned && !m.drained);
    const pinnedTriggers = new Set(pinned.map(m => m.trigger));

    const nonPinned = matching.filter(m => !pinnedTriggers.has(m.trigger));
    const slotsForDynamic = Math.max(0, max - pinned.length);

    return [...pinned, ...nonPinned.slice(0, slotsForDynamic)];
  }

  function createBubbleEl(memory: Memory): HTMLElement {
    const el = document.createElement('div');
    el.className = 'tp-bubble entering';
    if (memory.pinned) el.classList.add('pinned');

    const pinLabel = memory.pinned ? `<span class="tp-pin-indicator">pinned</span>` : '';

    el.innerHTML = `
      <div class="tp-bubble-text">
        <span>${memory.trigger}</span>
        <span class="tp-bubble-conf">${memory.confidence.toFixed(2)}</span>
        ${pinLabel}
        <span class="tp-bubble-actions">
          <button class="tp-bubble-btn pin" data-trigger="${memory.trigger}">${memory.pinned ? 'Unpin' : 'Pin'}</button>
          <button class="tp-bubble-btn drain" data-trigger="${memory.trigger}">Drain</button>
        </span>
      </div>
    `;

    el.querySelector('.tp-bubble-btn.pin')!.addEventListener('click', (e) => {
      e.stopPropagation();
      const trigger = (e.target as HTMLElement).dataset.trigger!;
      const mem = allMemories.find(m => m.trigger === trigger);
      if (mem) {
        mem.pinned = !mem.pinned;
        refreshPool();
      }
    });

    el.querySelector('.tp-bubble-btn.drain')!.addEventListener('click', (e) => {
      e.stopPropagation();
      const trigger = (e.target as HTMLElement).dataset.trigger!;
      const mem = allMemories.find(m => m.trigger === trigger);
      if (mem) {
        mem.drained = true;
        mem.pinned = false;
        refreshPool();
      }
    });

    return el;
  }

  function refreshPool() {
    const container = document.getElementById('tp-bubbles')!;
    const relevant = getRelevantMemories(currentContext, maxPoolSize);
    const relevantTriggers = new Set(relevant.map(m => m.trigger));

    // Remove bubbles no longer relevant
    const toRemove = activeBubbles.filter(b => !relevantTriggers.has(b.memory.trigger));
    toRemove.forEach(b => {
      if (b.el) {
        b.el.classList.remove('visible');
        b.el.classList.add('exiting');
        const elRef = b.el;
        setTimeout(() => elRef.remove(), 800);
      }
    });

    // Keep existing relevant bubbles
    const existingTriggers = new Set(activeBubbles.map(b => b.memory.trigger));
    const kept = activeBubbles.filter(b => relevantTriggers.has(b.memory.trigger));

    // Update pinned state on kept bubbles
    kept.forEach(b => {
      const memRef = allMemories.find(m => m.trigger === b.memory.trigger);
      if (memRef) {
        b.memory = memRef;
        if (b.el) {
          if (memRef.pinned) {
            b.el.classList.add('pinned');
          } else {
            b.el.classList.remove('pinned');
          }
          const pinBtn = b.el.querySelector('.tp-bubble-btn.pin') as HTMLElement;
          if (pinBtn) pinBtn.textContent = memRef.pinned ? 'Unpin' : 'Pin';

          const pinInd = b.el.querySelector('.tp-pin-indicator');
          if (memRef.pinned && !pinInd) {
            const confSpan = b.el.querySelector('.tp-bubble-conf');
            if (confSpan) {
              const indicator = document.createElement('span');
              indicator.className = 'tp-pin-indicator';
              indicator.textContent = 'pinned';
              confSpan.after(indicator);
            }
          } else if (!memRef.pinned && pinInd) {
            pinInd.remove();
          }
        }
      }
    });

    // Add new bubbles (use container size for responsive layout)
    const poolEl = document.getElementById('tp-pool')!;
    const poolWidth = Math.max(200, poolEl.offsetWidth);
    const poolHeight = Math.max(120, poolEl.offsetHeight);

    const toAdd = relevant.filter(m => !existingTriggers.has(m.trigger));

    toAdd.forEach((memory, i) => {
      const el = createBubbleEl(memory);
      const x = 30 + Math.random() * Math.max(40, poolWidth - 160);
      const y = 30 + Math.random() * Math.max(40, poolHeight - 60);
      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
      container.appendChild(el);

      requestAnimationFrame(() => {
        el.classList.remove('entering');
        el.classList.add('visible');
      });

      kept.push({
        memory,
        x,
        y,
        vx: (Math.random() - 0.5) * 0.15,
        vy: (Math.random() - 0.5) * 0.15,
        el
      });
    });

    activeBubbles = kept;
    refreshCount++;
    document.getElementById('tp-refresh-count')!.textContent = `Pool refreshed ${refreshCount} time${refreshCount === 1 ? '' : 's'} this session`;
  }

  function animateBubbles() {
    const poolEl = document.getElementById('tp-pool');
    const poolWidth = poolEl ? Math.max(200, poolEl.offsetWidth) : 500;
    const poolHeight = poolEl ? Math.max(120, poolEl.offsetHeight) : 260;

    activeBubbles.forEach(b => {
      if (!b.el) return;

      b.x += b.vx;
      b.y += b.vy;

      // Bounce off edges
      if (b.x < 10 || b.x > poolWidth - 140) b.vx *= -1;
      if (b.y < 15 || b.y > poolHeight - 40) b.vy *= -1;

      // Clamp
      b.x = Math.max(10, Math.min(poolWidth - 140, b.x));
      b.y = Math.max(15, Math.min(poolHeight - 40, b.y));

      b.el.style.left = `${b.x}px`;
      b.el.style.top = `${b.y}px`;
    });

    animFrameId = requestAnimationFrame(animateBubbles);
  }

  function renderOceanDots() {
    const ocean = document.getElementById('tp-ocean')!;
    for (let i = 0; i < 35; i++) {
      const dot = document.createElement('div');
      dot.className = 'tp-ocean-dot';
      dot.style.left = `${Math.random() * 100}%`;
      dot.style.top = `${Math.random() * 100}%`;
      dot.style.animationDelay = `${Math.random() * 12}s`;
      dot.style.animationDuration = `${8 + Math.random() * 8}s`;
      ocean.appendChild(dot);
    }
  }

  // Context buttons
  document.querySelectorAll('.tp-context-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tp-context-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentContext = (btn as HTMLElement).dataset.context!;
      document.getElementById('tp-context-display')!.textContent = contextLabels[currentContext];
      refreshPool();
    });
  });

  // Max pool size slider
  document.getElementById('tp-max-slider')!.addEventListener('input', (e) => {
    maxPoolSize = parseInt((e.target as HTMLInputElement).value);
    document.getElementById('tp-max-label')!.textContent = String(maxPoolSize);
    refreshPool();
  });

  // Initialize
  renderOceanDots();
  refreshPool();
  animateBubbles();
</script>
