---
import FailureModeLayout from '../../layouts/FailureModeLayout.astro';
import DoItWithDeja from '../../components/DoItWithDeja.astro';
import { getFailureModeBySlug } from '../../data/research';
const failureMode = getFailureModeBySlug('two-memories-conflict')!;
---

<FailureModeLayout failureMode={failureMode}>
  <Fragment slot="toc">
    <a href="#scenario" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Scenario</a>
    <a href="#what-was-needed" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What was needed</a>
    <a href="#minimal-interface" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Minimal interface</a>
    <a href="#do-it-with-deja" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Do it with deja</a>
  </Fragment>

  <h2 id="scenario">Scenario</h2>
  <p>"Use feature flags for standard deploys" and "Skip flags for hotfixes with team notification" both live in shared memory. The agent got both; behavior was inconsistent depending on which one ranked higher for the current context. You want one rule, not two — or at least to see the conflict and resolve it.</p>

  <h2 id="what-was-needed">What was needed</h2>
  <p>A contradiction view for shared scope only. Pairs of learnings above a similarity threshold, with actions: merge (one combined learning), keep one (delete the other), or scope one to context (e.g. "when it's a hotfix"). Link through to the actual memories so you can edit or delete. No full board — just "here are the pairs that might be conflicting."</p>

  <h2 id="minimal-interface">Minimal interface</h2>
  <p>One page: list of pairs. Each pair shows trigger/learning for A and B, similarity score, and buttons: Merge, Keep left, Keep right, Both valid (add context tags). Merging creates a new learning and deletes both originals; "both valid" leaves both but adds metadata so downstream logic can choose by context. The minimal version doesn't need LLM classification — you decide which pairs are real contradictions.</p>

  <DoItWithDeja
    blurb="List shared learnings, compute pairwise similarity (or use multiple injects). Show pairs above threshold; resolve with DELETE or PATCH."
    snippets={[
      {
        label: 'List shared, find pairs, resolve',
        code: `const { learnings } = await fetch('/learnings?scope=shared').then(r => r.json());
// Pairwise similarity: for each pair, POST /inject with one trigger, see if the other appears in top-k
// Or compute client-side if you have embeddings. Pairs with similarity > 0.85 → show in UI.
// Resolve: DELETE one, or PATCH both with context_tags. Merge = POST new learning + DELETE both.`,
      },
    ]}
  />
</FailureModeLayout>
