---
import ResearchLayout from '../../layouts/ResearchLayout.astro';
import DoItWithDeja from '../../components/DoItWithDeja.astro';
import { getConceptBySlug } from '../../data/research';
const concept = getConceptBySlug('memory-mesh')!;
---

<ResearchLayout concept={concept}>
  <div slot="demo">
    <div class="mesh-container border border-brass/20 rounded-sm bg-void-deep overflow-hidden">
      <!-- Header -->
      <div class="flex flex-wrap items-center justify-between gap-2 px-5 py-3 border-b border-brass/10 bg-steel/30">
        <span class="font-mono text-[10px] font-bold tracking-widest uppercase text-brass">Memory Mesh</span>
        <span class="font-mono text-[10px] text-chrome-dark/30" id="mesh-status">Click a node or edge to inspect</span>
      </div>

      <div class="flex">
        <!-- Canvas area -->
        <div class="flex-1 relative" style="min-height: 420px;">
          <canvas id="mesh-canvas" class="mesh-canvas"></canvas>
          <!-- Tooltip -->
          <div id="mesh-tooltip" class="mesh-tooltip hidden">
            <div id="tooltip-content"></div>
          </div>
        </div>

        <!-- Info panel -->
        <div class="w-56 border-l border-brass/10 p-4 hidden md:block">
          <div id="info-panel">
            <div class="font-mono text-[9px] font-bold tracking-widest uppercase text-chrome-dark/30 mb-3">Network Summary</div>
            <div class="space-y-3">
              <div class="summary-stat">
                <span class="font-mono text-[10px] text-chrome-dark/40">Primary hub</span>
                <span class="font-serif text-[13px] text-brass">deploy-bot</span>
              </div>
              <div class="summary-stat">
                <span class="font-mono text-[10px] text-chrome-dark/40">Most active flow</span>
                <span class="font-serif text-[13px] text-chrome">deploy-bot to test-runner</span>
              </div>
              <div class="summary-stat">
                <span class="font-mono text-[10px] text-chrome-dark/40">Total memories shared</span>
                <span class="font-serif text-[13px] text-chrome">64</span>
              </div>
              <div class="summary-stat">
                <span class="font-mono text-[10px] text-chrome-dark/40">Isolated consumer</span>
                <span class="font-serif text-[13px] text-blue-400">doc-writer</span>
              </div>
            </div>

            <div class="mt-5 pt-4 border-t border-brass/10">
              <div class="font-mono text-[9px] font-bold tracking-widest uppercase text-chrome-dark/30 mb-3">Selected</div>
              <div id="selection-info" class="font-serif text-[12px] text-chrome-dark/40">
                Nothing selected
              </div>
            </div>

            <div class="mt-5 pt-4 border-t border-brass/10">
              <div class="font-mono text-[9px] font-bold tracking-widest uppercase text-chrome-dark/30 mb-3">Legend</div>
              <div class="space-y-2">
                <div class="flex items-center gap-2">
                  <span class="inline-block w-3 h-3 rounded-full" style="background: #c9a961; box-shadow: 0 0 6px rgba(201,169,97,0.4);"></span>
                  <span class="font-mono text-[10px] text-chrome-dark/40">Net producer</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="inline-block w-3 h-3 rounded-full" style="background: #60a5fa; box-shadow: 0 0 6px rgba(96,165,250,0.4);"></span>
                  <span class="font-mono text-[10px] text-chrome-dark/40">Net consumer</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="inline-block w-3 h-3 rounded-full" style="background: #6b7280;"></span>
                  <span class="font-mono text-[10px] text-chrome-dark/40">Balanced</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="inline-block w-6 h-0.5 rounded" style="background: #c9a961;"></span>
                  <span class="font-mono text-[10px] text-chrome-dark/40">High-flow edge</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="inline-block w-6 h-px rounded" style="background: rgba(184,184,184,0.3);"></span>
                  <span class="font-mono text-[10px] text-chrome-dark/40">Low-flow edge</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <Fragment slot="toc">
    <a href="#the-experience" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">The experience</a>
    <a href="#what-it-reveals" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">What it reveals</a>
    <a href="#deja-connection" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Deja connection</a>
    <a href="#do-it-with-deja" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Do it with deja</a>
    <a href="#design-tensions" class="block py-1 text-[12px] font-serif text-chrome-dark/50 hover:text-brass transition-colors">Design tensions</a>
  </Fragment>

  <h2 id="the-experience">The experience</h2>

  <p>
    A network graph appears on screen. Five nodes arranged in a loose pentagon, each representing an agent in the system: <code>deploy-bot</code>, <code>test-runner</code>, <code>fix-it</code>, <code>monitor-bot</code>, and <code>doc-writer</code>. Edges connect them, varying in thickness based on how frequently memory flows between each pair. Animated particles drift along the edges, showing the direction of knowledge transfer -- tiny brass dots flowing from producer to consumer, like data packets in a network visualization.
  </p>
  <p>
    The thickest edge runs from <code>deploy-bot</code> to <code>test-runner</code>. This makes sense: the deployment agent generates a large volume of learnings about service behavior, port conflicts, migration quirks, and health check timing. The test runner consumes these learnings to inform its test strategies. The second thickest edge connects <code>test-runner</code> to <code>fix-it</code> -- test failures create a natural pipeline of knowledge that the fix-it agent needs.
  </p>
  <p>
    Node colors tell a story. <code>deploy-bot</code> glows brass, the color of a net producer: it creates more memories than it consumes. <code>doc-writer</code> glows blue, a net consumer: it consumes memories to generate documentation but rarely contributes new learnings back. <code>monitor-bot</code> sits in the middle, a balanced participant that both produces monitoring insights and consumes deployment and test data.
  </p>
  <p>
    Click on an edge and it expands to show which specific learnings flowed between those agents. The <code>deploy-bot</code> to <code>test-runner</code> edge reveals learnings like "auth-service requires full restart after migration #47" and "port 8080 conflicts intermittently on staging-02." Click on a node and all its connections highlight, with a profile appearing in the side panel: "deploy-bot -- Net producer: +7 (created 15, consumed 8)." The mesh transforms from an abstract visualization into a navigable map of organizational knowledge economics.
  </p>

  <h2 id="what-it-reveals">What it reveals</h2>

  <p>
    The Memory Mesh reveals knowledge economics -- a dimension of multi-agent systems that is invisible without explicit visualization. In any team, human or artificial, some participants naturally produce knowledge and others naturally consume it. This is not inherently good or bad. A healthy ecosystem needs both producers and consumers, just as a healthy economy needs both manufacturers and retailers. The problem arises when the dynamics are invisible.
  </p>
  <p>
    When you can see that <code>deploy-bot</code> is the primary knowledge hub, several questions become answerable. What happens if <code>deploy-bot</code> goes offline? Which downstream agents lose their primary knowledge source? Is there redundancy -- do other agents produce similar learnings that could substitute? The mesh makes these dependency chains visible, turning abstract concerns about system resilience into concrete, navigable relationships.
  </p>
  <p>
    The mesh also reveals isolation. In the demo, <code>doc-writer</code> has minimal connections -- it consumes a trickle of memories but contributes almost nothing. This might be fine (documentation agents are naturally downstream), or it might indicate a missed opportunity. If <code>doc-writer</code> is consuming memories and generating documentation, the quality assessments it makes during that process could be fed back as new learnings: "This memory is too vague to document" or "These three memories contradict each other." The mesh reveals where feedback loops are missing.
  </p>
  <p>
    Edge thickness encodes frequency, but it does not encode value. A thick edge between two agents might represent high-volume, low-value memory transfer (many trivial observations) or low-volume, high-value transfer (a few critical insights). This distinction matters for investment decisions. If you are optimizing your agent fleet, you want to invest in high-value producers, not just high-volume ones. The mesh provides a starting point, but deeper analysis requires examining what flows along each edge, not just how much.
  </p>

  <h2 id="deja-connection">How it connects to deja</h2>

  <p>
    Building the Memory Mesh on deja requires two additions to the data model. First, the <code>created_by</code> field on learnings needs to be structured and reliable. Deja already stores metadata about which agent created a learning, but this field needs to be a first-class, indexed property rather than freeform metadata. Every learning needs a clear provenance: which agent, which run, which timestamp.
  </p>
  <p>
    Second, the system needs a <code>memory_recalls</code> table (or log) that records when one agent recalls a memory that was created by another. Today, deja's <code>state_resolve</code> returns relevant memories, but it does not log which memories were actually used by the receiving agent or track the cross-agent dimension of that usage. A new logging mechanism would record: "agent X recalled learning Y (created by agent Z) during run W." This table is the raw material for computing edge weights in the mesh.
  </p>
  <p>
    The API surface for the mesh would include: <code>GET /mesh/agents</code> returning all agents with their production and consumption statistics, <code>GET /mesh/flows</code> returning all agent pairs with flow frequency and volume, and <code>GET /mesh/flows/:fromAgent/:toAgent</code> returning the specific learnings that have flowed between two agents. These are read-only analytical endpoints -- they do not change system behavior, they illuminate it.
  </p>
  <p>
    The more interesting engineering challenge is computing flow direction. When <code>deploy-bot</code> creates a learning and <code>test-runner</code> later recalls it, that is a clear directional flow. But when a learning is in the shared scope, it becomes ambiguous. If <code>deploy-bot</code> contributed a shared learning and <code>test-runner</code> recalls it, did knowledge "flow" from deploy-bot to test-runner, or did both agents independently access a shared resource? The mesh needs to distinguish between direct transfers (agent-to-agent via shared scope) and indirect consumption (both agents drawing from a common pool). This distinction has real implications for understanding knowledge dependencies.
  </p>

  <DoItWithDeja
    blurb="List learnings with contributor (created_by). Aggregate flows from your inject logs or run store. Mesh needs recall logs (future)."
    snippets={[
      {
        label: 'List learnings with contributor metadata',
        code: `curl -X GET "https://deja.your-subdomain.workers.dev/learnings?scope=shared" \\
  -H "Authorization: Bearer YOUR_API_KEY"
# Group by created_by; aggregate cross-agent flows from run trace if available`,
      },
    ]}
  />

  <h2 id="design-tensions">Design tensions</h2>

  <p>
    <strong>The business question the mesh answers.</strong> "Which agents should we invest in?" In any fleet of agents, some are more valuable than others. The mesh provides a way to measure that value: knowledge hub agents -- those with high production and high recall-by-others -- are systematically more valuable than isolated agents. If <code>deploy-bot</code> produces learnings that are recalled 200 times across the fleet, and <code>doc-writer</code> produces learnings that are recalled twice, the investment case for improving <code>deploy-bot</code>'s memory capabilities is clear. The mesh makes the knowledge economy legible to decision-makers.
  </p>
  <p>
    <strong>Network effects and fragility.</strong> A mesh with a single dominant hub is efficient but fragile. If <code>deploy-bot</code> is the source of 60% of all cross-agent memory flows, the system has a single point of knowledge failure. The mesh visualization makes this concentration visible, but it also raises a design question: should the system actively encourage knowledge diversification? Perhaps when the mesh detects a dangerously central hub, it should prompt other agents to develop similar competencies. This moves from passive visualization to active system optimization -- a much harder problem.
  </p>
  <p>
    <strong>Directionality vs. mutuality.</strong> The mesh as described uses directed edges -- memory flows from producer to consumer. But some agent relationships are mutual: <code>deploy-bot</code> and <code>monitor-bot</code> exchange knowledge bidirectionally. The visualization needs to handle both one-way and two-way flows clearly. In the demo, animated particles show direction, but in a static view (a screenshot, a report), directionality needs a different encoding. Arrow thickness, color gradients, or split edges are all options, each with tradeoffs in clarity.
  </p>
  <p>
    <strong>Privacy and competitive dynamics.</strong> In multi-tenant systems, the mesh reveals which agents know what. This is valuable for system administrators, but it could create competitive dynamics if agents (or the teams that manage them) can see each other's knowledge flows. Agent A's team might not want Agent B's team to know how much knowledge Agent A produces. This sounds anthropomorphic, but in enterprise environments, agent fleets are managed by different teams with different incentives. The mesh needs access controls: who can see which edges, and at what granularity.
  </p>
  <p>
    <strong>Scale and readability.</strong> Five agents make a clean pentagon. Fifty agents make an unreadable hairball. The mesh visualization needs to scale gracefully. Clustering by team or by function, filtering by flow threshold, and progressive disclosure (start with top-level clusters, drill into individual agents) are all necessary for production use. The demo's clean layout is only possible because the network is small. Real-world knowledge meshes will be far more complex, and the visualization must degrade gracefully rather than becoming noise.
  </p>
  <p>
    The Memory Mesh is ultimately a tool for organizational self-awareness. It answers questions that most multi-agent systems cannot even ask: Where does knowledge come from? Where does it go? Who depends on whom? These are the same questions that organizational theorists have studied in human companies for decades. The mesh brings that analytical lens to agent systems, where the answers are computable rather than estimated. The question is whether seeing the knowledge economy clearly leads to better decisions about it -- and the early evidence from analogous human systems suggests that it does.
  </p>
</ResearchLayout>

<style>
  .mesh-container {
    box-shadow:
      inset 0 1px 0 rgba(201, 169, 97, 0.05),
      0 4px 24px rgba(0, 0, 0, 0.5);
  }

  .mesh-canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
  }

  .mesh-tooltip {
    position: absolute;
    pointer-events: none;
    background: #1a1a1a;
    border: 1px solid rgba(201, 169, 97, 0.2);
    border-radius: 2px;
    padding: 10px 14px;
    max-width: 280px;
    z-index: 10;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
  }

  .mesh-tooltip.hidden {
    display: none;
  }

  .summary-stat {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
</style>

<script>
  interface AgentNode {
    id: string;
    x: number;
    y: number;
    created: number;
    consumed: number;
    radius: number;
    color: string;
    glowColor: string;
  }

  interface Edge {
    from: string;
    to: string;
    weight: number;
    learnings: string[];
  }

  interface Particle {
    edge: Edge;
    t: number;
    speed: number;
  }

  const agents: AgentNode[] = [
    { id: 'deploy-bot', x: 0, y: 0, created: 15, consumed: 8, radius: 32, color: '#c9a961', glowColor: 'rgba(201,169,97,0.4)' },
    { id: 'test-runner', x: 0, y: 0, created: 12, consumed: 14, radius: 28, color: '#6b7280', glowColor: 'rgba(107,114,128,0.3)' },
    { id: 'fix-it', x: 0, y: 0, created: 8, consumed: 16, radius: 26, color: '#60a5fa', glowColor: 'rgba(96,165,250,0.4)' },
    { id: 'monitor-bot', x: 0, y: 0, created: 10, consumed: 11, radius: 27, color: '#6b7280', glowColor: 'rgba(107,114,128,0.3)' },
    { id: 'doc-writer', x: 0, y: 0, created: 3, consumed: 15, radius: 22, color: '#60a5fa', glowColor: 'rgba(96,165,250,0.4)' },
  ];

  const edges: Edge[] = [
    { from: 'deploy-bot', to: 'test-runner', weight: 18, learnings: [
      'Auth-service requires full restart after migration #47',
      'Port 8080 conflicts intermittently on staging-02',
      'Health endpoint returns 503 for ~12s after restart',
      'Use --dry-run flag before staging deploys',
    ]},
    { from: 'deploy-bot', to: 'fix-it', weight: 10, learnings: [
      'Migration #47 skips session_tokens index on hot-reload',
      'Rollback requires manual Redis cache clear',
    ]},
    { from: 'test-runner', to: 'fix-it', weight: 16, learnings: [
      'Token-refresh test fails intermittently (possible clock skew)',
      'Integration suite needs sandbox API key, not production',
      'Parallel test runs cause flakiness in recommendation engine tests',
    ]},
    { from: 'monitor-bot', to: 'deploy-bot', weight: 6, learnings: [
      'Latency spikes after nightly restart correlate with cold cache',
      'Analytics worker memory leak triggers after 48 hours',
    ]},
    { from: 'deploy-bot', to: 'doc-writer', weight: 4, learnings: [
      'Auth-service v2.4.1 deployment requires migration step',
    ]},
    { from: 'test-runner', to: 'doc-writer', weight: 3, learnings: [
      'Integration test requirements for payment flow',
    ]},
    { from: 'monitor-bot', to: 'fix-it', weight: 5, learnings: [
      'Staging-02 port 8080 occupied by monitoring dashboard during sweeps',
    ]},
    { from: 'fix-it', to: 'deploy-bot', weight: 2, learnings: [
      'Port 8081 confirmed safe alternative on staging-02',
    ]},
  ];

  let particles: Particle[] = [];
  let selectedNode: AgentNode | null = null;
  let selectedEdge: Edge | null = null;
  let hoveredNode: AgentNode | null = null;
  let hoveredEdge: Edge | null = null;

  const canvas = document.getElementById('mesh-canvas') as HTMLCanvasElement;
  const tooltip = document.getElementById('mesh-tooltip');
  const tooltipContent = document.getElementById('tooltip-content');
  const selectionInfo = document.getElementById('selection-info');
  const meshStatus = document.getElementById('mesh-status');

  function setupCanvas() {
    const parent = canvas.parentElement;
    if (!parent) return;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = parent.clientWidth * dpr;
    canvas.height = parent.clientHeight * dpr;
    canvas.style.width = parent.clientWidth + 'px';
    canvas.style.height = parent.clientHeight + 'px';

    const ctx = canvas.getContext('2d');
    if (ctx) ctx.scale(dpr, dpr);

    positionNodes(parent.clientWidth, parent.clientHeight);
  }

  function positionNodes(w: number, h: number) {
    const cx = w / 2;
    const cy = h / 2;
    const r = Math.min(w, h) * 0.34;

    agents.forEach((agent, i) => {
      const angle = -Math.PI / 2 + (i * 2 * Math.PI) / agents.length;
      agent.x = cx + Math.cos(angle) * r;
      agent.y = cy + Math.sin(angle) * r;
    });
  }

  function getNode(id: string): AgentNode | undefined {
    return agents.find(a => a.id === id);
  }

  function initParticles() {
    particles = [];
    edges.forEach(edge => {
      const count = Math.max(1, Math.floor(edge.weight / 5));
      for (let i = 0; i < count; i++) {
        particles.push({
          edge,
          t: Math.random(),
          speed: 0.002 + Math.random() * 0.003,
        });
      }
    });
  }

  function draw() {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0, 0, w, h);

    // Draw edges
    edges.forEach(edge => {
      const from = getNode(edge.from);
      const to = getNode(edge.to);
      if (!from || !to) return;

      const isSelected = selectedEdge === edge || (selectedNode && (selectedNode.id === edge.from || selectedNode.id === edge.to));
      const isHovered = hoveredEdge === edge;
      const lineWidth = Math.max(1, edge.weight / 4);
      const alpha = isSelected ? 0.6 : isHovered ? 0.5 : 0.15;

      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = isSelected || isHovered ? `rgba(201,169,97,${alpha})` : `rgba(184,184,184,${alpha})`;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    });

    // Draw particles
    particles.forEach(p => {
      const from = getNode(p.edge.from);
      const to = getNode(p.edge.to);
      if (!from || !to) return;

      p.t += p.speed;
      if (p.t > 1) p.t = 0;

      const x = from.x + (to.x - from.x) * p.t;
      const y = from.y + (to.y - from.y) * p.t;

      const isRelevant = selectedNode
        ? (selectedNode.id === p.edge.from || selectedNode.id === p.edge.to)
        : selectedEdge
        ? selectedEdge === p.edge
        : true;

      const alpha = isRelevant ? 0.8 : 0.15;
      const size = isRelevant ? 2.5 : 1.5;

      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(201,169,97,${alpha})`;
      ctx.fill();
    });

    // Draw nodes
    agents.forEach(agent => {
      const isSelected = selectedNode === agent;
      const isHovered = hoveredNode === agent;
      const isConnected = selectedNode && edges.some(e =>
        (e.from === selectedNode!.id && e.to === agent.id) ||
        (e.to === selectedNode!.id && e.from === agent.id)
      );
      const dimmed = selectedNode && !isSelected && !isConnected;

      // Glow
      if (isSelected || isHovered) {
        ctx.beginPath();
        ctx.arc(agent.x, agent.y, agent.radius + 8, 0, Math.PI * 2);
        const grd = ctx.createRadialGradient(agent.x, agent.y, agent.radius, agent.x, agent.y, agent.radius + 12);
        grd.addColorStop(0, agent.glowColor);
        grd.addColorStop(1, 'transparent');
        ctx.fillStyle = grd;
        ctx.fill();
      }

      // Node circle
      ctx.beginPath();
      ctx.arc(agent.x, agent.y, agent.radius, 0, Math.PI * 2);
      ctx.fillStyle = dimmed ? '#111' : '#1a1a1a';
      ctx.fill();
      ctx.strokeStyle = dimmed ? 'rgba(184,184,184,0.05)' : isSelected ? agent.color : 'rgba(184,184,184,0.15)';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.stroke();

      // Agent name
      ctx.font = '11px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = dimmed ? 'rgba(184,184,184,0.15)' : isSelected ? agent.color : 'rgba(232,232,232,0.8)';
      ctx.fillText(agent.id.replace('-', '-'), agent.x, agent.y - 4);

      // Stats
      ctx.font = '9px "JetBrains Mono", monospace';
      ctx.fillStyle = dimmed ? 'rgba(184,184,184,0.08)' : 'rgba(184,184,184,0.35)';
      ctx.fillText(`${agent.created}c / ${agent.consumed}r`, agent.x, agent.y + 10);
    });

    requestAnimationFrame(draw);
  }

  function getDistance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }

  function pointToLineDistance(px: number, py: number, x1: number, y1: number, x2: number, y2: number): number {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let t = lenSq !== 0 ? dot / lenSq : -1;
    t = Math.max(0, Math.min(1, t));
    const nearX = x1 + t * C;
    const nearY = y1 + t * D;
    return getDistance(px, py, nearX, nearY);
  }

  function findNodeAt(mx: number, my: number): AgentNode | null {
    for (const agent of agents) {
      if (getDistance(mx, my, agent.x, agent.y) < agent.radius + 5) {
        return agent;
      }
    }
    return null;
  }

  function findEdgeAt(mx: number, my: number): Edge | null {
    for (const edge of edges) {
      const from = getNode(edge.from);
      const to = getNode(edge.to);
      if (!from || !to) continue;
      const dist = pointToLineDistance(mx, my, from.x, from.y, to.x, to.y);
      if (dist < 8) return edge;
    }
    return null;
  }

  function updateSelection() {
    if (!selectionInfo) return;

    if (selectedNode) {
      const net = selectedNode.created - selectedNode.consumed;
      const netLabel = net > 0 ? `Net producer: +${net}` : net < 0 ? `Net consumer: ${net}` : 'Balanced';
      const role = net > 2 ? 'producer' : net < -2 ? 'consumer' : 'balanced';
      const outEdges = edges.filter(e => e.from === selectedNode!.id);
      const inEdges = edges.filter(e => e.to === selectedNode!.id);

      selectionInfo.innerHTML = `
        <div style="font-family: var(--font-family-serif); font-size: 14px; color: #e8e8e8; margin-bottom: 6px; font-weight: 600;">${selectedNode.id}</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: ${role === 'producer' ? '#c9a961' : role === 'consumer' ? '#60a5fa' : '#6b7280'}; margin-bottom: 8px;">${netLabel}</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.4); margin-bottom: 2px;">Created: ${selectedNode.created} memories</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.4); margin-bottom: 8px;">Recalled by others: ${selectedNode.consumed}</div>
        ${outEdges.length > 0 ? `<div style="font-family: var(--font-family-mono); font-size: 9px; color: rgba(201,169,97,0.4); margin-bottom: 4px;">FLOWS OUT TO</div>
        ${outEdges.map(e => `<div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.5); margin-bottom: 2px;">${e.to} (${e.weight} memories)</div>`).join('')}` : ''}
        ${inEdges.length > 0 ? `<div style="font-family: var(--font-family-mono); font-size: 9px; color: rgba(96,165,250,0.4); margin-top: 6px; margin-bottom: 4px;">FLOWS IN FROM</div>
        ${inEdges.map(e => `<div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.5); margin-bottom: 2px;">${e.from} (${e.weight} memories)</div>`).join('')}` : ''}
      `;
    } else if (selectedEdge) {
      selectionInfo.innerHTML = `
        <div style="font-family: var(--font-family-serif); font-size: 13px; color: #e8e8e8; margin-bottom: 6px;">${selectedEdge.from} to ${selectedEdge.to}</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(201,169,97,0.5); margin-bottom: 8px;">${selectedEdge.weight} memories transferred</div>
        <div style="font-family: var(--font-family-mono); font-size: 9px; color: rgba(184,184,184,0.3); margin-bottom: 4px;">LEARNINGS SHARED</div>
        ${selectedEdge.learnings.map(l => `<div style="font-family: var(--font-family-serif); font-size: 11px; color: rgba(184,184,184,0.6); margin-bottom: 4px; padding-left: 8px; border-left: 2px solid rgba(201,169,97,0.15);">${l}</div>`).join('')}
      `;
    } else {
      selectionInfo.innerHTML = '<span style="color: rgba(184,184,184,0.4);">Nothing selected</span>';
    }
  }

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    hoveredNode = findNodeAt(mx, my);
    hoveredEdge = hoveredNode ? null : findEdgeAt(mx, my);

    canvas.style.cursor = (hoveredNode || hoveredEdge) ? 'pointer' : 'default';

    if (hoveredEdge && tooltip && tooltipContent) {
      tooltipContent.innerHTML = `
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: #c9a961; margin-bottom: 4px;">${hoveredEdge.from} to ${hoveredEdge.to}</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.5);">${hoveredEdge.weight} memories -- click to inspect</div>
      `;
      tooltip.classList.remove('hidden');
      tooltip.style.left = (mx + 15) + 'px';
      tooltip.style.top = (my - 10) + 'px';
    } else if (hoveredNode && tooltip && tooltipContent) {
      const net = hoveredNode.created - hoveredNode.consumed;
      tooltipContent.innerHTML = `
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: ${hoveredNode.color}; margin-bottom: 4px;">${hoveredNode.id}</div>
        <div style="font-family: var(--font-family-mono); font-size: 10px; color: rgba(184,184,184,0.5);">Created: ${hoveredNode.created} -- Consumed: ${hoveredNode.consumed} -- Net: ${net > 0 ? '+' : ''}${net}</div>
      `;
      tooltip.classList.remove('hidden');
      tooltip.style.left = (mx + 15) + 'px';
      tooltip.style.top = (my - 10) + 'px';
    } else if (tooltip) {
      tooltip.classList.add('hidden');
    }
  });

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const clickedNode = findNodeAt(mx, my);
    const clickedEdge = clickedNode ? null : findEdgeAt(mx, my);

    if (clickedNode) {
      selectedNode = selectedNode === clickedNode ? null : clickedNode;
      selectedEdge = null;
    } else if (clickedEdge) {
      selectedEdge = selectedEdge === clickedEdge ? null : clickedEdge;
      selectedNode = null;
    } else {
      selectedNode = null;
      selectedEdge = null;
    }

    if (meshStatus) {
      if (selectedNode) meshStatus.textContent = `Inspecting: ${selectedNode.id}`;
      else if (selectedEdge) meshStatus.textContent = `Flow: ${selectedEdge.from} to ${selectedEdge.to}`;
      else meshStatus.textContent = 'Click a node or edge to inspect';
    }

    updateSelection();
  });

  canvas.addEventListener('mouseleave', () => {
    hoveredNode = null;
    hoveredEdge = null;
    if (tooltip) tooltip.classList.add('hidden');
  });

  setupCanvas();
  initParticles();
  draw();

  window.addEventListener('resize', () => {
    setupCanvas();
  });
</script>
